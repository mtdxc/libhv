# libhvæ•™ç¨‹00--ç›®å½•

`libhv`æ˜¯ä¸€ä¸ªæ¯”`libeventã€libevã€libuv`æ›´æ˜“ç”¨çš„è·¨å¹³å°å›½äº§ç½‘ç»œåº“ï¼Œç”¨æ¥å¼€å‘`TCP/UDP/SSL/HTTP/WebSocket `å®¢æˆ·ç«¯/æœåŠ¡ç«¯ã€‚

é¡¹ç›®åœ°å€ï¼š<https://github.com/ithewei/libhv.git>

ç äº‘é•œåƒï¼š<https://gitee.com/libhv/libhv.git>

QQæŠ€æœ¯äº¤æµç¾¤ï¼š**739352073**

libhvåšå®¢ä¸“æ ï¼š<https://hewei.blog.csdn.net/category_9866493.html>

libhvæºç åˆ†æï¼š<https://blog.csdn.net/qu1993/category_10637982.html>

## ğŸ“š æ•™ç¨‹ç›®å½•

- [libhvæ•™ç¨‹01--ä»‹ç»ä¸ä½“éªŒ](https://hewei.blog.csdn.net/article/details/113702536)
- [libhvæ•™ç¨‹02--ç¼–è¯‘ä¸å®‰è£…](https://hewei.blog.csdn.net/article/details/113704737)
- [libhvæ•™ç¨‹03--é“¾åº“ä¸ä½¿ç”¨](https://hewei.blog.csdn.net/article/details/113706378)
- [libhvæ•™ç¨‹04--ç¼–å†™ä¸€ä¸ªå®Œæ•´çš„å‘½ä»¤è¡Œç¨‹åº](https://hewei.blog.csdn.net/article/details/113719503)
- [libhvæ•™ç¨‹05--äº‹ä»¶å¾ªç¯ä»¥åŠå®šæ—¶å™¨çš„ç®€å•ä½¿ç”¨](https://hewei.blog.csdn.net/article/details/113724474)
- [libhvæ•™ç¨‹06--åˆ›å»ºä¸€ä¸ªç®€å•çš„TCPæœåŠ¡ç«¯](https://hewei.blog.csdn.net/article/details/113737580)
- [libhvæ•™ç¨‹07--åˆ›å»ºä¸€ä¸ªç®€å•çš„TCPå®¢æˆ·ç«¯](https://hewei.blog.csdn.net/article/details/113738900)
- [libhvæ•™ç¨‹08--åˆ›å»ºä¸€ä¸ªç®€å•çš„UDPæœåŠ¡ç«¯](https://hewei.blog.csdn.net/article/details/113871498)
- [libhvæ•™ç¨‹09--åˆ›å»ºä¸€ä¸ªç®€å•çš„UDPå®¢æˆ·ç«¯](https://hewei.blog.csdn.net/article/details/113871724)
- [libhvæ•™ç¨‹10--åˆ›å»ºä¸€ä¸ªç®€å•çš„HTTPæœåŠ¡ç«¯](https://hewei.blog.csdn.net/article/details/113982999)
- [libhvæ•™ç¨‹11--åˆ›å»ºä¸€ä¸ªç®€å•çš„HTTPå®¢æˆ·ç«¯](https://hewei.blog.csdn.net/article/details/113984302)
- [libhvæ•™ç¨‹12--åˆ›å»ºä¸€ä¸ªç®€å•çš„WebSocketæœåŠ¡ç«¯](https://hewei.blog.csdn.net/article/details/113985321)
- [libhvæ•™ç¨‹13--åˆ›å»ºä¸€ä¸ªç®€å•çš„WebSocketå®¢æˆ·ç«¯](https://hewei.blog.csdn.net/article/details/113985895)
- [libhvæ•™ç¨‹14--200è¡Œå®ç°ä¸€ä¸ªçº¯Cç‰ˆjsonrpcæ¡†æ¶](https://hewei.blog.csdn.net/article/details/119920540)
- [libhvæ•™ç¨‹15--200è¡Œå®ç°ä¸€ä¸ªC++ç‰ˆprotorpcæ¡†æ¶](https://hewei.blog.csdn.net/article/details/119966701)
- [libhvæ•™ç¨‹16--å¤šçº¿ç¨‹/å¤šè¿›ç¨‹æœåŠ¡ç«¯ç¼–ç¨‹](https://hewei.blog.csdn.net/article/details/120366024)
- [libhvæ•™ç¨‹17--Qtä¸­ä½¿ç”¨libhv](https://hewei.blog.csdn.net/article/details/120699890)
- [libhvæ•™ç¨‹18--åŠ¨æ‰‹å†™ä¸€ä¸ªtinyhttpd](https://hewei.blog.csdn.net/article/details/121706604)
- [libhvæ•™ç¨‹19--MQTTçš„å®ç°ä¸ä½¿ç”¨](https://hewei.blog.csdn.net/article/details/122753665)

## ğŸ­ ç¤ºä¾‹ä»£ç 
### cç‰ˆæœ¬
- äº‹ä»¶å¾ªç¯: [examples/hloop_test.c](../examples/hloop_test.c)
- TCPå›æ˜¾æœåŠ¡:  [examples/tcp_echo_server.c](../examples/tcp_echo_server.c)
- TCPèŠå¤©æœåŠ¡:  [examples/tcp_chat_server.c](../examples/tcp_chat_server.c)
- TCPä»£ç†æœåŠ¡:  [examples/tcp_proxy_server.c](../examples/tcp_proxy_server.c)
- UDPå›æ˜¾æœåŠ¡:  [examples/udp_echo_server.c](../examples/udp_echo_server.c)
- UDPä»£ç†æœåŠ¡:  [examples/udp_proxy_server.c](../examples/udp_proxy_server.c)
- jsonRPCç¤ºä¾‹: [examples/jsonrpc](../examples/jsonrpc)
- tinyhttpdç¤ºä¾‹: [examples/tinyhttpd.c](../examples/tinyhttpd.c)

### c++ç‰ˆæœ¬
- äº‹ä»¶å¾ªç¯: [evpp/EventLoop_test.cpp](../evpp/EventLoop_test.cpp)
- äº‹ä»¶å¾ªç¯çº¿ç¨‹: [evpp/EventLoopThread_test.cpp](../evpp/EventLoopThread_test.cpp)
- äº‹ä»¶å¾ªç¯çº¿ç¨‹æ± : [evpp/EventLoopThreadPool_test.cpp](../evpp/EventLoopThreadPool_test.cpp)
- TCPæœåŠ¡ç«¯: [evpp/TcpServer_test.cpp](../evpp/TcpServer_test.cpp)
- TCPå®¢æˆ·ç«¯: [evpp/TcpClient_test.cpp](../evpp/TcpClient_test.cpp)
- UDPæœåŠ¡ç«¯: [evpp/UdpServer_test.cpp](../evpp/UdpServer_test.cpp)
- UDPå®¢æˆ·ç«¯: [evpp/UdpClient_test.cpp](../evpp/UdpClient_test.cpp)
- HTTPæœåŠ¡ç«¯: [examples/http_server_test.cpp](../examples/http_server_test.cpp)
- HTTPå®¢æˆ·ç«¯: [examples/http_client_test.cpp](../examples/http_client_test.cpp)
- WebSocketæœåŠ¡ç«¯: [examples/websocket_server_test.cpp](../examples/websocket_server_test.cpp)
- WebSocketå®¢æˆ·ç«¯: [examples/websocket_client_test.cpp](../examples/websocket_client_test.cpp)
- protobufRPCç¤ºä¾‹: [examples/protorpc](../examples/protorpc)

### æ¨¡æ‹Ÿå®ç°è‘—åçš„å‘½ä»¤è¡Œå·¥å…·
- ç½‘ç»œè¿æ¥å·¥å…·: [examples/nc](../examples/nc.c)
- ç½‘ç»œæ‰«æå·¥å…·: [examples/nmap](../examples/nmap)
- HTTPæœåŠ¡ç¨‹åº: [examples/httpd](../examples/httpd)
- URLè¯·æ±‚å·¥å…·: [examples/curl](../examples/curl.cpp)
- æ–‡ä»¶ä¸‹è½½å·¥å…·: [examples/wget](../examples/wget.cpp)
- æœåŠ¡æ³¨å†Œä¸å‘ç°: [examples/consul](../examples/consul)

åˆ›ä½œä¸æ˜“ï¼Œå¦‚æœä½ è§‰å¾—ä¸é”™ï¼Œè¯·åœ¨ [github](https://github.com/ithewei/libhv) ä¸Š`star`ä¸‹å§ã€‚

------

# libhvæ•™ç¨‹01--ä»‹ç»ä¸ä½“éªŒ

## åç§°ç”±æ¥

`libhv`æ˜¯ä¸€ä¸ªç±»ä¼¼äº`libeventã€libevã€libuv`çš„è·¨å¹³å°ç½‘ç»œåº“ï¼Œæä¾›äº†å¸¦éé˜»å¡IOå’Œå®šæ—¶å™¨çš„äº‹ä»¶å¾ªç¯ã€‚
libhvçš„åç§°ä¹Ÿæ­£æ˜¯ç»§æ‰¿æ­¤æ´¾ï¼Œå¯“æ„é«˜æ€§èƒ½çš„äº‹ä»¶å¾ªç¯`High-performance event loop library`ã€‚

## libhvèƒ½å¹²ä»€ä¹ˆ
- ç¼–å†™è·¨å¹³å°c/c++ç¨‹åºï¼›
- åŸºäºTCP/UDP/SSLå¼€å‘è‡ªå®šä¹‰åè®®ç½‘ç»œç¨‹åºï¼›
- ç¼–å†™HTTPå®¢æˆ·ç«¯/æœåŠ¡ç«¯ç¨‹åºï¼›
- ç¼–å†™WebSocketå®¢æˆ·ç«¯/æœåŠ¡ç«¯ç¨‹åºï¼›
- å­¦ä¹ å®è·µç½‘ç»œç¼–ç¨‹ï¼›

## libhvå’Œlibeventã€libevã€libuvæœ‰ä»€ä¹ˆä¸åŒ
- libeventæœ€ä¸ºå¤è€ã€æœ‰å†å²åŒ…è¢±ï¼Œbuffereventè™½ä¸ºç²¾å¦™ï¼Œå´ä¹Ÿéš¾ä»¥ä¸Šæ‰‹ï¼›
- libevå¯ä»¥è¯´æ˜¯libeventçš„ç®€åŒ–ç‰ˆï¼Œä»£ç æä¸ºç²¾ç®€ï¼Œä½†å®å®šä¹‰ç”¨çš„è¿‡å¤šï¼Œä»£ç å¯è¯»æ€§ä¸å¼ºï¼Œä¸”åœ¨Windowsä¸Šå®ç°ä¸ä½³ï¼›
- libuvæ˜¯nodejsçš„cåº•å±‚åº“ï¼Œæœ€å…ˆä¹Ÿæ˜¯ç”±libevent+å¯¹Windows IOCPæ”¯æŒï¼Œåæ¥æ‰æ”¹å†™è‡ªæˆä¸€ä½“ï¼ŒåŒæ—¶å®ç°äº†ç®¡é“ã€æ–‡ä»¶çš„å¼‚æ­¥è¯»å†™ï¼Œå¾ˆå¼ºå¤§ï¼Œä½†ç»“æ„ä½“æ¯”è¾ƒå¤šï¼Œå°è£…æ¯”è¾ƒæ·±ï¼›
- libhvæœ¬èº«æ˜¯å‚è€ƒäº†libeventã€libevã€libuvçš„å®ç°æ€è·¯ï¼Œå®ƒä»¬çš„æ ¸å¿ƒéƒ½æ˜¯äº‹ä»¶å¾ªç¯ï¼ˆå³åœ¨ä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­å¤„ç†IOã€å®šæ—¶å™¨ç­‰äº‹ä»¶ï¼‰ï¼Œä½†æä¾›çš„æ¥å£æœ€ä¸ºç²¾ç®€ï¼ŒAPIæ¥è¿‘åŸç”Ÿç³»ç»Ÿè°ƒç”¨ï¼Œæœ€å®¹æ˜“ä¸Šæ‰‹ï¼›
- å…·ä½“è¿™å‡ ä¸ªåº“çš„å†™æ³•æ¯”è¾ƒè§[echo-servers](https://github.com/ithewei/libhv/tree/master/echo-servers)ï¼Œå¯è§libhvæ˜¯æœ€ç®€å•çš„ï¼›
- æ­¤å¤–libhvæ”¯æŒå¿ƒè·³ã€è½¬å‘ã€æ‹†åŒ…ã€å¤šçº¿ç¨‹å®‰å…¨writeå’Œcloseç­‰ç‰¹æ€§ï¼Œæä¾›äº†HTTPã€WebSocketç­‰åè®®å®ç°ï¼›
- å½“ç„¶è¿™å‡ ä¸ªåº“çš„æ€§èƒ½æ˜¯æ¥è¿‘çš„ï¼Œéƒ½å°†éé˜»å¡IOå¤šè·¯å¤ç”¨ç”¨åˆ°äº†æè‡´;

## ä½“éªŒ

linuxä¸macä¸‹çš„ç”¨æˆ·å¯ç›´æ¥æ‰§è¡Œ`./getting_started.sh`è„šæœ¬ï¼Œå³å¯ä½“éªŒä½¿ç”¨libhvç¼–å†™çš„httpæœåŠ¡ç«¯`httpd`ä¸httpå®¢æˆ·ç«¯`curl`çš„ä¾¿åˆ©ä¹‹å¤„ã€‚

è¿è¡Œæ•ˆæœå¦‚ä¸‹:
```shell
$ ./getting_started.sh
Welcome to libhv!
Press any key to run ...

bin/httpd -c etc/httpd.conf -s restart -d

httpd start/running
hw               83110   0.0  0.0  5100160    588   ??  S     4:14ä¸‹åˆ   0:00.00 httpd: worker process
hw               83109   0.0  0.0  4951680    580   ??  S     4:14ä¸‹åˆ   0:00.00 httpd: worker process
hw               83108   0.0  0.0  4820608    572   ??  S     4:14ä¸‹åˆ   0:00.00 httpd: worker process
hw               83107   0.0  0.0  4689536    600   ??  S     4:14ä¸‹åˆ   0:00.00 httpd: worker process
hw               83103   0.0  0.0  4950656    808   ??  Ss    4:14ä¸‹åˆ   0:00.00 httpd: master process

bin/curl -v localhost:8080

GET / HTTP/1.1
Accept: */*
Connection: keep-alive
Content-Length: 0
Host: localhost:8080
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36


HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 130
Content-Type: text/html
Date: Fri, 05 Feb 2021 08:14:14 GMT
Etag: "5fc1057e-82"
Last-Modified: Fri, 27 Nov 2020 13:56:14 GMT
Server: httpd/1.21.2.5

<!DOCTYPE html>
<html>
<head>
  <title>httpd</title>
</head>
<body>
  <center><h1>Welcome to httpd!</h1></center>
</body>
</html>
```

httpdä¸curlä»£ç å‡å¯åœ¨[examples](https://github.com/ithewei/libhv/tree/master/examples)ç›®å½•ä¸‹æ‰¾åˆ°ï¼Œæ˜¯å®Œæ•´çš„å‘½ä»¤è¡Œç¨‹åºã€‚

```shell
$ bin/httpd -h
Usage: httpd [hvc:ts:dp:]
Options:

  -h|--help                 Print this information
  -v|--version              Print version
  -c|--confile <confile>    Set configure file, default etc/{program}.conf
  -t|--test                 Test configure file and exit
  -s|--signal <signal>      Send <signal> to process,
                            <signal>=[start,stop,restart,status,reload]
  -d|--daemon               Daemonize
  -p|--port <port>          Set listen port
```

```shell
$ bin/curl -h
Usage: curl [hVvX:H:d:F:n:] url
Options:
    -h|--help           Print this message.
    -V|--version        Print version.
    -v|--verbose        Show verbose infomation.
    -X|--method         Set http method.
    -H|--header         Add http headers, -H "Content-Type:application/json Accept:*/*"
    -d|--data           Set http body.
    -F|--form           Set http form, -F "name1=content;name2=@filename"
    -n|--count          Send request count, used for test keep-alive
       --http2          Use http2
       --grpc           Use grpc over http2
Examples:
    curl -v localhost:8080
    curl -v localhost:8080/hello
    curl -v localhost:8080/query?page_no=1&page_size=10
    curl -v localhost:8080/echo  -d 'hello,world!'
    curl -v localhost:8080/kv    -H "Content-Type:application/x-www-form-urlencoded" -d 'user=admin&pswd=123456'
    curl -v localhost:8080/json  -H "Content-Type:application/json"                  -d '{"user":"admin","pswd":"123456"}'
    curl -v localhost:8080/form  -F 'file=@filename'
```

å½“ç„¶ä½ ä¹Ÿå¯ä»¥é€šè¿‡æµè§ˆå™¨è®¿é—®ï¼Œåœ°å€æ è¾“å…¥ï¼š
- 127.0.0.1:8080/
- 127.0.0.1:8080/downloads/
- 127.0.0.1:8080/ping
![/downloads/](https://img-blog.csdnimg.cn/2021020519182285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dHX1NpTWlEYQ==,size_16,color_FFFFFF,t_70)

------

# libhvæ•™ç¨‹02--ç¼–è¯‘ä¸å®‰è£…

libhvæä¾›äº†åŸç”Ÿ`Makefile`ï¼ˆè¿™é‡Œä»…æŒ‡é€‚ç”¨äºç±»unixç³»ç»Ÿçš„Makefileï¼‰å’Œ`cmake`ä¸¤ç§æ„å»ºæ–¹å¼ã€‚

## Makefileå‘½ä»¤è¡Œ
`CLI`å³`Command Line Interface`å‘½ä»¤è¡Œç•Œé¢ã€‚é„™äººå¼ºçƒˆæ¨èä½¿ç”¨çš„ä¸€ç§ï¼Œç‰¹åˆ«æ˜¯å¯¹äºæœåŠ¡ç«¯å¼€å‘äººå‘˜ï¼Œå¿…å¤‡æŠ€èƒ½ã€‚

å¯¹äºç±»Unixç³»ç»Ÿå¹³å°æ¥è¯´ï¼Œæ¨èä½¿ç”¨`Makefileä¸‰éƒ¨æ›²`
```bash
./configure
make
sudo make install
```

Windowså¹³å°ç¼–è¯‘libhvè¯·ä½¿ç”¨cmakeå…ˆç”ŸæˆVSå·¥ç¨‹ï¼Œå„å¹³å°å…·ä½“ç¼–è¯‘æ­¥éª¤è§[BUILD.md](../BUILD.md)

## cmakeå‘½ä»¤è¡Œ
```bash
cmake -B build
cmake --build build
```
## cmakeå›¾å½¢ç•Œé¢ï¼ˆç…§é¡¾ä¸‹å°ç™½ï¼‰
![libhv-cmake](https://img-blog.csdnimg.cn/20210205220719695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dHX1NpTWlEYQ==,size_16,color_FFFFFF,t_70#pic_center)
ä¸€èˆ¬ä½¿ç”¨é»˜è®¤é…ç½®å³å¯ï¼Œå¦‚éœ€å‹¾é€‰`WITH_OPENSSL`ï¼Œè¯·å…ˆè‡ªè¡Œå®‰è£…`openssl`

## vcpkg
ä¹Ÿå¯é€šè¿‡`vcpkg`å®‰è£…ï¼š
```shell
vcpkg install libhv
```
æ³¨ï¼švcpkgä¸Šçš„ç‰ˆæœ¬å¯èƒ½æ›´æ–°è¾ƒæ…¢ï¼Œå¦‚éœ€ä½“éªŒæœ€æ–°ç‰ˆè¿˜æ˜¯æ¨èä¸‹è½½æºç ç¼–è¯‘ã€‚

## ç¼–è¯‘äº§ç‰©
### å¤´æ–‡ä»¶
ç±»unixç³»ç»Ÿé»˜è®¤å®‰è£…åœ¨`/usr/local/include/hv`ç›®å½•ä¸‹
```bash
.
â”œâ”€â”€ Buffer.h                ç¼“å­˜ç±»
â”œâ”€â”€ Callback.h              å›è°ƒå®šä¹‰
â”œâ”€â”€ Channel.h               IOé€šé“ç±»
â”œâ”€â”€ Event.h                 äº‹ä»¶ç±»
â”œâ”€â”€ EventLoop.h             äº‹ä»¶å¾ªç¯ç±»
â”œâ”€â”€ EventLoopThread.h       äº‹ä»¶å¾ªç¯çº¿ç¨‹ç±»
â”œâ”€â”€ EventLoopThreadPool.h   äº‹ä»¶å¾ªç¯çº¿ç¨‹æ± ç±»
â”œâ”€â”€ HttpMessage.h           HTTPæ¶ˆæ¯ç±»
â”œâ”€â”€ HttpParser.h            HTTPè§£æç±»
â”œâ”€â”€ HttpServer.h            HTTPæœåŠ¡ç±»
â”œâ”€â”€ HttpService.h           HTTPä¸šåŠ¡ç±»
â”œâ”€â”€ Status.h                çŠ¶æ€ç±»
â”œâ”€â”€ TcpClient.h             TCPå®¢æˆ·ç«¯ç±»
â”œâ”€â”€ TcpServer.h             TCPæœåŠ¡ç«¯ç±»
â”œâ”€â”€ ThreadLocalStorage.h    çº¿ç¨‹æœ¬åœ°å­˜å‚¨ç±»
â”œâ”€â”€ UdpClient.h             UDPå®¢æˆ·ç«¯ç±»
â”œâ”€â”€ UdpServer.h             UDPæœåŠ¡ç«¯ç±»
â”œâ”€â”€ WebSocketChannel.h      WebSocketé€šé“ç±»
â”œâ”€â”€ WebSocketClient.h       WebSocketå®¢æˆ·ç«¯ç±»
â”œâ”€â”€ WebSocketParser.h       WebSocketè§£æç±»
â”œâ”€â”€ WebSocketServer.h       WebSocketæœåŠ¡ç«¯ç±»
â”œâ”€â”€ base64.h                BASE64ç¼–è§£ç 
â”œâ”€â”€ grpcdef.h               grpcå®šä¹‰
â”œâ”€â”€ hatomic.h               åŸå­æ“ä½œ
â”œâ”€â”€ hbase.h                 åŸºæœ¬å‡½æ•°
â”œâ”€â”€ hbuf.h                  ç¼“å­˜buffer
â”œâ”€â”€ hconfig.h               configureç”Ÿæˆé…ç½®
â”œâ”€â”€ hdef.h                  å¸¸è§å®å®šä¹‰
â”œâ”€â”€ hdir.h                  ç›®å½•ï¼ˆlså®ç°ï¼‰
â”œâ”€â”€ hendian.h               å¤§å°ç«¯
â”œâ”€â”€ herr.h                  é”™è¯¯ç å®šä¹‰
â”œâ”€â”€ hexport.h               DLLå¯¼å‡ºå®
â”œâ”€â”€ hfile.h                 æ–‡ä»¶ç±»
â”œâ”€â”€ hlog.h                  æ—¥å¿—
â”œâ”€â”€ hloop.h                 äº‹ä»¶å¾ªç¯
â”œâ”€â”€ hmain.h                 å‘½ä»¤è¡Œè§£æ
â”œâ”€â”€ hmath.h                 æ•°å­¦å‡½æ•°
â”œâ”€â”€ hmutex.h                äº’æ–¥é”
â”œâ”€â”€ hobjectpool.h           å¯¹è±¡æ± 
â”œâ”€â”€ hplatform.h             å¹³å°ç›¸å…³å®
â”œâ”€â”€ hproc.h                 è¿›ç¨‹
â”œâ”€â”€ hscope.h                ä½œç”¨åŸŸ
â”œâ”€â”€ hsocket.h               å¥—æ¥å­—
â”œâ”€â”€ hssl.h                  SSL/TLSåŠ å¯†
â”œâ”€â”€ hstring.h               å­—ç¬¦ä¸²æ“ä½œ
â”œâ”€â”€ hsysinfo.h              ç³»ç»Ÿä¿¡æ¯
â”œâ”€â”€ hthread.h               çº¿ç¨‹æ“ä½œ
â”œâ”€â”€ hthreadpool.h           çº¿ç¨‹æ± ç±»
â”œâ”€â”€ htime.h                 æ—¥æœŸæ—¶é—´
â”œâ”€â”€ http2def.h              http2å®šä¹‰
â”œâ”€â”€ http_client.h           HTTPå®¢æˆ·ç«¯
â”œâ”€â”€ http_content.h          HTTP Content-Type
â”œâ”€â”€ httpdef.h               httpå®šä¹‰
â”œâ”€â”€ hurl.h                  URLæ“ä½œ
â”œâ”€â”€ hv.h                    hvæ€»å¤´æ–‡ä»¶
â”œâ”€â”€ hversion.h              ç‰ˆæœ¬
â”œâ”€â”€ ifconfig.h              ifconfigå®ç°
â”œâ”€â”€ iniparser.h             INIè§£æç±»
â”œâ”€â”€ json.hpp                JSONè§£æ
â”œâ”€â”€ md5.h                   MD5æ•°å­—æ‘˜è¦
â”œâ”€â”€ nlog.h                  ç½‘ç»œæ—¥å¿—
â”œâ”€â”€ nmap.h                  ä¸»æœºå‘ç°
â”œâ”€â”€ requests.h              æ¨¡æ‹Ÿpython requests api
â”œâ”€â”€ sha1.h                  SHA1å®‰å…¨æ•£åˆ—ç®—æ³•
â””â”€â”€ singleton.h             å•ä¾‹æ¨¡å¼å®
```

### åº“æ–‡ä»¶
- é™æ€åº“`libhv.a`æˆ–`libhv_static.a`
- `windows`åŠ¨æ€åº“`hv.dll`
- `linux`åŠ¨æ€åº“`libhv.so`
- `macosx`åŠ¨æ€åº“`libhv.dylib`

### ç¤ºä¾‹ç¨‹åº
```bash
â”œâ”€â”€ hmain_test          å‘½ä»¤è¡Œè§£ææµ‹è¯•ç¨‹åº
â”œâ”€â”€ hloop_test          äº‹ä»¶å¾ªç¯æµ‹è¯•ç¨‹åº
â”œâ”€â”€ htimer_test         å®šæ—¶å™¨æµ‹è¯•ç¨‹åº
â”œâ”€â”€ http_client_test    HTTPå®¢æˆ·ç«¯æµ‹è¯•ç¨‹åº
â”œâ”€â”€ http_server_test    HTTPæœåŠ¡ç«¯æµ‹è¯•ç¨‹åº
â”œâ”€â”€ websocket_client_test    WebSocketå®¢æˆ·ç«¯æµ‹è¯•ç¨‹åº
â”œâ”€â”€ websocket_server_test    WebSocketæœåŠ¡ç«¯æµ‹è¯•ç¨‹åº
â”œâ”€â”€ curl                HTTPå®¢æˆ·ç«¯
â”œâ”€â”€ httpd               HTTPæœåŠ¡ç«¯
â”œâ”€â”€ nc                  ç½‘ç»œå®¢æˆ·ç«¯
â”œâ”€â”€ nmap                ä¸»æœºå‘ç°
â”œâ”€â”€ tcp_chat_server     TCPèŠå¤©æœåŠ¡
â”œâ”€â”€ tcp_echo_server     TCPå›æ˜¾æœåŠ¡
â”œâ”€â”€ tcp_proxy_server    TCPä»£ç†æœåŠ¡
â””â”€â”€ udp_echo_server     UDPå›æ˜¾æœåŠ¡
```

å¦å¤–ï¼Œä»“åº“é€šè¿‡ [Github Actions](https://github.com/ithewei/libhv/actions) ç¡®ä¿`master`åˆ†æ”¯åœ¨`linuxã€windowsã€macosx`ä¸‰ä¸ªå¹³å°ç¼–è¯‘é€šè¿‡ï¼Œå¤§å®¶å†ä¹Ÿä¸ç”¨æ‹…å¿ƒç¼–è¯‘ä¸è¿‡äº†ã€‚

------

# libhvæ•™ç¨‹03--é“¾åº“ä¸ä½¿ç”¨

åœ¨ä¸Šä¸€ç¯‡ä¸­ï¼Œæˆ‘ä»¬å·²ç»ç”Ÿæˆäº†å¤´æ–‡ä»¶ä¸åº“æ–‡ä»¶ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å†™ä¸ªæµ‹è¯•ç¨‹åºé“¾åº“éªŒè¯ä¸‹ã€‚

æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š
```c
#include "hv/hv.h"

int main() {
    char exe_filepath[MAX_PATH] = {0};
    char run_dir[MAX_PATH] = {0};

    // è·å–hvç¼–è¯‘ç‰ˆæœ¬
    const char* version = hv_compile_version();

    // è·å–å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„
    get_executable_path(exe_filepath, sizeof(exe_filepath));
    // è·å–è¿è¡Œç›®å½•
    get_run_dir(run_dir, sizeof(run_dir));

    printf("exe_filepath=%s\n", exe_filepath);
    printf("run_dir=%s\n", run_dir);

    // å†™æ—¥å¿—
    LOGI("libhv version: %s", version);

    return 0;
}
```

ç¼–è¯‘è¿è¡Œï¼š
```shell
$ cc -std=c99 test.c -o test -lhv
$ ./test
exe_filepath=/home/hw/github/libhv/test
run_dir=/home/hw/github/libhv
$ cat libhv*.log
2021-02-06 00:16:40.989 INFO  libhv version: 1.21.1.31 [test.c:19:main]
```

## windowsé“¾åº“è¯´æ˜

cmakeç”Ÿæˆvså·¥ç¨‹ï¼Œæ‰“å¼€`hv.sln`ç¼–è¯‘åä¼šç”Ÿæˆå¤´æ–‡ä»¶`include/hv`ã€é™æ€åº“`lib/hv_static.lib`å’ŒåŠ¨æ€åº“`lib/hv.dll`ï¼Œæ‰€ä»¥æœ‰åŠ¨æ€åº“å’Œé™æ€åº“ä¸¤ç§é“¾åº“æ–¹å¼ã€‚

### åŠ¨æ€å¯¼å…¥åº“hv.lib + åŠ¨æ€åº“hv.dll
å·¥ç¨‹ => å±æ€§ => Linker => Input => Addtional Dependencies åŠ `hv.lib`
æˆ–ä»£ç é‡Œæ·»åŠ 

    #pragma comment(lib, "hv.lib")

### é™æ€åº“å£°æ˜å®HV_STATICLIB + é™æ€åº“hv_static.lib
å·¥ç¨‹ => å±æ€§ => c/c++ => é¢„å¤„ç†å™¨ => é¢„å¤„ç†å™¨å®šä¹‰ä¸­æ·»åŠ `HV_STATICLIB`é¢„ç¼–è¯‘å®ï¼Œä»¥å±è”½`hexport.h`å¤´æ–‡ä»¶ä¸­åŠ¨æ€åº“å¯¼å…¥å®

    #define HV_EXPORT __declspec(dllimport)

å·¥ç¨‹ => å±æ€§ => Linker => Input => Addtional Dependencies åŠ  `hv_static.lib`
æˆ–ä»£ç é‡Œæ·»åŠ 

    #pragma comment(lib, "hv_static.lib")

------

# libhvæ•™ç¨‹04--ç¼–å†™ä¸€ä¸ªå®Œæ•´çš„å‘½ä»¤è¡Œç¨‹åº

é¦–å…ˆï¼Œä¸€ä¸ªå®Œæ•´çš„å‘½ä»¤è¡Œç¨‹åºåº”è¯¥åŒ…å«å“ªäº›åŠŸèƒ½ï¼Ÿ

- å‘½ä»¤è¡Œå‚æ•°è§£æ
- é…ç½®æ–‡ä»¶è§£æ
- æ‰“å°å¸®åŠ©ä¿¡æ¯å’Œç‰ˆæœ¬ä¿¡æ¯
- ä¿¡å·å¤„ç†
- æ—¥å¿—ã€pidæ–‡ä»¶
- å¦‚æœæ˜¯æœåŠ¡ç«¯é•¿æ—¶é—´è¿è¡Œåå°ç¨‹åºï¼Œè¿˜éœ€è¦çœ‹é—¨ç‹—ï¼ˆå´©æºƒè‡ªåŠ¨é‡å¯ï¼‰

çœ‹çœ‹libhvæ˜¯å¦‚ä½•æä¾›è¿™äº›åŠŸèƒ½çš„ï¼Œå‚è€ƒç¤ºä¾‹ä»£ç è§[examples/hmain_test.cpp](../examples/hmain_test.cpp)

ç¼–è¯‘è¿è¡Œï¼š
```shell
$ c++ -std=c++11 examples/hmain_test.cpp -o bin/hmain_test -I/usr/local/include/hv -lhv

$ bin/hmain_test -h
Usage: hmain_test [hvc:ts:dp:]
Options:

  -h|--help                 Print this information
  -v|--version              Print version
  -c|--confile <confile>    Set configure file, default etc/{program}.conf
  -t|--test                 Test configure file and exit
  -s|--signal <signal>      Send <signal> to process,
                            <signal>=[start,stop,restart,status,reload]
  -d|--daemon               Daemonize
  -p|--port <port>          Set listen port

$ bin/hmain_test -v
hmain_test version 1.21.1.31

$ bin/hmain_test -c etc/hmain_test.conf -t
Test confile [etc/hmain_test.conf] OK!

$ bin/hmain_test -d

$ bin/hmain_test -s restart -d
hmain_test stop/waiting
hmain_test start/running

$ bin/hmain_test -s status
hmain_test start/running, pid=27766

$ cat logs/hmain_test.pid
27776

$ cat logs/hmain_test*.log
2021-02-06 12:18:53.509 INFO  hmain_test version: 1.21.1.31 [hmain_test.cpp:94:parse_confile]
2021-02-06 12:18:53.509 DEBUG worker_processes=ncpu=2 [hmain_test.cpp:103:parse_confile]
2021-02-06 12:18:53.509 INFO  parse_confile('/home/hw/github/libhv/etc/hmain_test.conf') OK [hmain_test.cpp:129:parse_confile]
2021-02-06 12:18:53.509 INFO  create_pidfile('/home/hw/github/libhv/logs/hmain_test.pid') pid=27766 [hmain.cpp:317:create_pidfile]
2021-02-06 12:18:53.509 INFO  workers[0] start/running, pid=27767 [hmain.cpp:611:master_workers_run]
2021-02-06 12:18:53.509 INFO  workers[1] start/running, pid=27768 [hmain.cpp:611:master_workers_run]
2021-02-06 12:18:53.509 INFO  master start/running, pid=27766 [hmain.cpp:614:master_workers_run]
2021-02-06 12:18:53.509 INFO  worker_thread pid=27767 tid=27767 [hmain.cpp:539:worker_thread]
2021-02-06 12:18:53.510 INFO  worker_thread pid=27768 tid=27768 [hmain.cpp:539:worker_thread]
2021-02-06 12:18:53.510 INFO  worker_thread pid=27767 tid=27769 [hmain.cpp:539:worker_thread]
2021-02-06 12:18:53.510 INFO  worker_thread pid=27768 tid=27770 [hmain.cpp:539:worker_thread]

$ ps aux | grep hmain_test
hw       27776  0.0  0.0  18000  2084 ?        Ss   12:20   0:00 hmain_test: master process
hw       27777  0.0  0.0  91732   240 ?        Sl   12:20   0:00 hmain_test: worker process
hw       27778  0.0  0.0  91732   240 ?        Sl   12:20   0:00 hmain_test: worker process

$ sudo kill -9 27778
$ ps aux | grep hmain_test
hw       27776  0.0  0.0  18000  2084 ?        Ss   12:20   0:00 hmain_test: master process
hw       27777  0.0  0.0  91732   240 ?        Sl   12:20   0:00 hmain_test: worker process
hw       27796  0.0  0.0  91732   244 ?        Sl   12:27   0:00 hmain_test: worker process
```

å¯ä»¥çœ‹åˆ°ï¼Œ`hmain_test`æä¾›äº†æ‰“å°å¸®åŠ©ä¿¡æ¯ã€æ‰“å°ç‰ˆæœ¬ä¿¡æ¯ã€æµ‹è¯•é…ç½®æ–‡ä»¶ã€åå°è¿è¡Œã€åˆ›å»ºpidæ–‡ä»¶ã€æŸ¥çœ‹è¿›ç¨‹çŠ¶æ€ã€å¼€å§‹ï½œåœæ­¢ï½œé‡å¯è¿›ç¨‹ã€`master-workers`å¤šè¿›ç¨‹æ¨¡å¼ã€å´©æºƒè‡ªåŠ¨é‡å¯ç­‰åŠŸèƒ½ã€‚

æµç¨‹å›¾ï¼š
```flow

st=>start: main
e=>end: ç»“æŸ

main_ctx_init=>operation: main_ctx_init
mainå…¥å£åˆå§‹åŒ–
parse_opt=>operation: parse_opt
è§£æå‘½ä»¤è¡Œå‚æ•°
parse_confile=>operation: parse_confile
è§£æé…ç½®æ–‡ä»¶
hlog_set_xxx=>operation: hlog_set_xxx
æ—¥å¿—è®¾ç½®
signal_init=>operation: signal_init
ä¿¡å·åˆå§‹åŒ–
signal_handle=>operation: signal_handle
ä¿¡å·å¤„ç†
daemon=>operation: daemon
åå°è¿è¡Œ
create_pidfile=>operation: create_pidfile
åˆ›å»ºpidæ–‡ä»¶
master_workers_run=>operation: master_workers_run
æ‰©å±•å¤šè¿›ç¨‹ï½œå¤šçº¿ç¨‹æ¨¡å¼
run=>operation: worker_fn
é•¿æ—¶é—´è¿è¡Œ...

st->main_ctx_init->parse_opt->parse_confile->hlog_set_xxx(left)->signal_init->signal_handle(right)->daemon->create_pidfile->master_workers_run->run

```

------

# libhvæ•™ç¨‹05--äº‹ä»¶å¾ªç¯ä»¥åŠå®šæ—¶å™¨çš„ç®€å•ä½¿ç”¨

## äº‹ä»¶å¾ªç¯ç®€ä»‹
å¾ˆå¤šåŒå­¦ä¸ç†è§£äº‹ä»¶å¾ªç¯çš„æ¦‚å¿µï¼Œæ‰€ä»¥è¿™é‡Œæœ‰å¿…è¦å‰ç½®è¯´æ˜ä¸€ä¸‹ã€‚
å¯¹äºå¤§å¤šæ•°é•¿æ—¶é—´è¿è¡Œç¨‹åºæ¥è¯´ï¼Œéƒ½ä¼šæœ‰ä¸»å¾ªç¯çš„å­˜åœ¨ã€‚

å¦‚çª—å£ç•Œé¢ç¨‹åºï¼Œå°±æ˜¯ç­‰å¾…é”®ç›˜ã€é¼ æ ‡ç­‰å¤–è®¾çš„è¾“å…¥ï¼Œç•Œé¢åšå‡ºç›¸åº”çš„å˜åŒ–ã€‚
æˆ‘ä»¬ä»¥`windowsçª—å£æ¶ˆæ¯æœºåˆ¶`ä¸¾ä¾‹è¯´æ˜ï¼š
```c
// windowsçª—å£æ¶ˆæ¯å¾ªç¯
MSG msg;
while (GetMessage(&msg, NULL, 0, 0)) {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
}
```
æ­¤å¾ªç¯æ‰€åœ¨çš„çº¿ç¨‹æˆ‘ä»¬ç§°ä¹‹ä¸º`GUIçº¿ç¨‹`ï¼ˆå³çª—å£æ‰€åœ¨çº¿ç¨‹ï¼‰ï¼Œ`MFCã€WPFã€Qt`ç­‰ç•Œé¢æ¡†æ¶ä¸è¿‡æ˜¯å°†æ­¤è¿‡ç¨‹ç»™å°è£…äº†ã€‚

ç†è§£äº†çª—å£æ¶ˆæ¯å¾ªç¯çš„å­˜åœ¨ï¼Œå…¶å®å°±ä¸éš¾ç†è§£windowsä¸‹è€ç”Ÿå¸¸è°ˆçš„é—®é¢˜ï¼š`SendMessage`ä¸`PostMessage`çš„åŒºåˆ«ã€‚
`SendMessage`å’Œ`PostMessage`éƒ½æ˜¯windowsæä¾›çš„ç”¨æ¥å‘çª—å£çº¿ç¨‹å‘é€æ¶ˆæ¯çš„APIã€‚
ä¸åŒä¹‹å¤„æ˜¯`SendMessage`æ˜¯åŒæ­¥çš„ï¼Œå¦‚æœ`SendMessage`è°ƒç”¨çº¿ç¨‹å’Œçª—å£çº¿ç¨‹ä½äºåŒä¸€çº¿ç¨‹ï¼Œåˆ™ç›´æ¥è°ƒç”¨çª—å£è¿‡ç¨‹å¤„ç†æ­¤æ¶ˆæ¯ï¼›å¦‚æœä¸æ˜¯åŒä¸€çº¿ç¨‹ï¼Œåˆ™ä¼šé˜»å¡ç­‰å¾…çª—å£çº¿ç¨‹å¤„ç†å®Œæ­¤æ¶ˆæ¯å†è¿”å›ã€‚
`PostMessage`æ˜¯å¼‚æ­¥çš„ï¼Œå°†æ¶ˆæ¯æŠ•é€’åˆ°çª—å£æ¶ˆæ¯é˜Ÿåˆ—ä¸­å°±è¿”å›äº†ï¼Œæ‰€ä»¥ä½¿ç”¨`PostMessage`ä¼ é€’å‚æ•°æ—¶éœ€è¦æ³¨æ„ä¸èƒ½ä½¿ç”¨æ ˆä¸Šçš„å±€éƒ¨å˜é‡ã€‚

## IOå¤šè·¯å¤ç”¨ç®€ä»‹
`GUIçº¿ç¨‹å…·æœ‰ä¸»å¾ªç¯ï¼Œç½‘ç»œIOçº¿ç¨‹äº¦æ˜¯å¦‚æ­¤ã€‚`

æˆ‘ä»¬éƒ½çŸ¥é“IOå¯åˆ†ä¸º`é˜»å¡BIO`ä¸`éé˜»å¡NIO`ã€‚
libhvçš„å¤´æ–‡ä»¶[hsocket.h](../base/hsocket.h)ä¸­æä¾›äº†è·¨å¹³å°çš„è®¾ç½®é˜»å¡ä¸éé˜»å¡çš„æ–¹æ³•ï¼š
```c
#ifdef OS_WIN
static inline int blocking(int sockfd) {
    unsigned long nb = 0;
    return ioctlsocket(sockfd, FIONBIO, &nb);
}
static inline int nonblocking(int sockfd) {
    unsigned long nb = 1;
    return ioctlsocket(sockfd, FIONBIO, &nb);
}
#else
#define blocking(s)     fcntl(s, F_SETFL, fcntl(s, F_GETFL) & ~O_NONBLOCK)
#define nonblocking(s)  fcntl(s, F_SETFL, fcntl(s, F_GETFL) |  O_NONBLOCK)
#endif
```
å¯¹äºBIOï¼Œä¼ªä»£ç å¦‚ä¸‹ï¼š
```c
while (1) {
    readbytes = read(fd, buf, len);
    if (readbytes <= 0) {
        close(fd);
        break;
    }
    ...
    writebytes = write(fd, buf, len);
    if (writebytes <= 0) {
        close(fd);
        break;
    }
}
```
å› ä¸ºè¯»å†™éƒ½æ˜¯é˜»å¡çš„ï¼Œæ‰€ä»¥ä¸€ä¸ªIOçº¿ç¨‹åªèƒ½å¤„ç†ä¸€ä¸ªfdï¼Œå¯¹äºå®¢æˆ·ç«¯å°šå¯æ¥å—ï¼Œå¯¹äºæœåŠ¡ç«¯æ¥è¯´ï¼Œæ¯`accept`ä¸€ä¸ªè¿æ¥ï¼Œå°±åˆ›å»ºä¸€ä¸ªIOçº¿ç¨‹å»è¯»å†™è¿™ä¸ªå¥—æ¥å­—ï¼Œå¹¶å‘è¾¾åˆ°å‡ åƒå°±éœ€è¦åˆ›å»ºå‡ åƒä¸ªçº¿ç¨‹ï¼Œçº¿ç¨‹ä¸Šä¸‹æ–‡çš„åˆ‡æ¢å¼€é”€éƒ½ä¼šæŠŠç³»ç»Ÿå æ»¡ã€‚

æ‰€ä»¥IOå¤šè·¯å¤ç”¨æœºåˆ¶åº”è¿è€Œç”Ÿï¼Œå¦‚æœ€æ—©æœŸçš„`select`ã€åæ¥çš„`poll`ï¼Œ`linux`çš„`epoll`ã€`windows`çš„`iocp`ã€`bsd`çš„`kqueue`ã€`solaris`çš„`port`ç­‰ï¼Œéƒ½å±äºIOå¤šè·¯å¤ç”¨æœºåˆ¶ã€‚`éé˜»å¡NIOæ­é…IOå¤šè·¯å¤ç”¨æœºåˆ¶å°±æ˜¯é«˜å¹¶å‘çš„é’¥åŒ™`ã€‚

å…³äº`selectã€pollã€epoll`çš„åŒºåˆ«ï¼Œå¯è‡ªè¡Œç™¾åº¦ï¼Œè¿™é‡Œå°±ä¸å±•å¼€è¯´äº†ã€‚ä»…ä»¥selectä¸ºä¾‹ï¼Œå†™ä¸‹ä¼ªä»£ç ï¼š
```c
while (1) {
    int nselect = select(max_fd+1, &readfds, &writefds, &exceptfds, timeout);
    if (nselect == 0) continue;
    for (int fd = 0; fd <= max_fd; ++fd) {
    	// å¯è¯»
    	if (FD_ISSET(fd, &readfds)) {
    		...
    		read(fd, buf, len);
    	}
    	// å¯å†™
    	if (FD_ISSET(fd, &writefds)) {
    		...
    		write(fd, buf, len);
    	}
    }
}
```
é€šè¿‡IOå¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œä¸€ä¸ªIOçº¿ç¨‹å°±å¯ä»¥åŒæ—¶ç›‘å¬å¤šä¸ªfdäº†ï¼Œä»¥ç°ä»£è®¡ç®—æœºçš„æ€§èƒ½ï¼Œä¸€ä¸ªIOçº¿ç¨‹å³å¯å¤„ç†å‡ åä¸‡æ•°é‡çº§åˆ«çš„IOè¯»å†™ã€‚

libhvä¸‹çš„[eventæ¨¡å—](https://github.com/ithewei/libhv/tree/master/event)æ­£æ˜¯`å°è£…äº†å¤šç§å¹³å°çš„IOå¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œæä¾›äº†ç»Ÿä¸€çš„äº‹ä»¶æ¥å£`ï¼Œæ˜¯libhvçš„æ ¸å¿ƒæ¨¡å—ã€‚

libhvä¸­çš„äº‹ä»¶åŒ…æ‹¬`IOäº‹ä»¶`ã€`timerå®šæ—¶å™¨äº‹ä»¶`ã€`idleç©ºé—²äº‹ä»¶`ã€`è‡ªå®šä¹‰äº‹ä»¶`ï¼ˆè§`hloop_post_event`æ¥å£ï¼Œä½œç”¨ç±»ä¼¼äºwindowsçª—å£æ¶ˆæ¯æœºåˆ¶çš„`PostMessage`ï¼‰ã€‚

æºç åˆ†ææ¨èç¾¤å‹[qu1993çš„åšå®¢](https://blog.csdn.net/qu1993/category_10637982.html)

## ä½¿ç”¨libhvåˆ›å»ºä¸€ä¸ªäº‹ä»¶å¾ªç¯
### cç‰ˆæœ¬
```c
#include "hv/hloop.h"

// å®šæ—¶å™¨å›è°ƒå‡½æ•°
static void on_timer(htimer_t* timer) {
    printf("time=%lus\n", (unsigned long)time(NULL));
}

int main() {
    // æ–°å»ºä¸€ä¸ªäº‹ä»¶å¾ªç¯ç»“æ„ä½“
    hloop_t* loop = hloop_new(0);

    // æ·»åŠ ä¸€ä¸ªå®šæ—¶å™¨
    htimer_add(loop, on_timer, 1000, INFINITE);

    // è¿è¡Œäº‹ä»¶å¾ªç¯
    hloop_run(loop);

    // é‡Šæ”¾äº‹ä»¶å¾ªç¯ç»“æ„ä½“
    hloop_free(&loop);
    return 0;
}
```

äº‹ä»¶å¾ªç¯æµ‹è¯•ä»£ç [examples/hloop_test.c](../examples/hloop_test.c)
å®šæ—¶å™¨æµ‹è¯•ä»£ç è§[examples/htimer_test.c](../examples/htimer_test.c)

### c++ç‰ˆæœ¬
```cpp
#include "hv/EventLoop.h"

using namespace hv;

int main() {
    // æ–°å»ºä¸€ä¸ªäº‹ä»¶å¾ªç¯å¯¹è±¡
    EventLoopPtr loop(new EventLoop);

    // è®¾ç½®ä¸€ä¸ªå®šæ—¶å™¨
    loop->setInterval(1000, [](TimerID timerID){
        printf("time=%lus\n", (unsigned long)time(NULL));
    });

    // è¿è¡Œäº‹ä»¶å¾ªç¯
    loop->run();

    return 0;
}
```
[evppæ¨¡å—](https://github.com/ithewei/libhv/tree/master/evpp)è¢«è®¾è®¡æˆåªåŒ…å«å¤´æ–‡ä»¶ï¼Œä¸å‚ä¸ç¼–è¯‘ã€‚ hloop.hä¸­çš„cæ¥å£è¢«å°è£…æˆäº†c++çš„ç±»ï¼Œå‚è€ƒäº†muduoå’Œevppã€‚ 
ç±»è®¾è®¡å¦‚ä¸‹ï¼š
```
â”œâ”€â”€ Buffer.h                ç¼“å­˜ç±»
â”œâ”€â”€ Channel.h               é€šé“ç±»ï¼Œå°è£…äº†hio_t
â”œâ”€â”€ Event.h                 äº‹ä»¶ç±»ï¼Œå°è£…äº†hevent_tã€htimer_t
â”œâ”€â”€ EventLoop.h             äº‹ä»¶å¾ªç¯ç±»ï¼Œå°è£…äº†hloop_t
â”œâ”€â”€ EventLoopThread.h       äº‹ä»¶å¾ªç¯çº¿ç¨‹ç±»ï¼Œç»„åˆäº†EventLoopå’Œthread
â”œâ”€â”€ EventLoopThreadPool.h   äº‹ä»¶å¾ªç¯çº¿ç¨‹æ± ç±»ï¼Œç»„åˆäº†EventLoopå’ŒThreadPool
â”œâ”€â”€ TcpClient.h             TCPå®¢æˆ·ç«¯ç±»
â”œâ”€â”€ TcpServer.h             TCPæœåŠ¡ç«¯ç±»
â”œâ”€â”€ UdpClient.h             UDPå®¢æˆ·ç«¯ç±»
â””â”€â”€ UdpServer.h             UDPæœåŠ¡ç«¯ç±»

```
ç¤ºä¾‹ä»£ç ä½äºevppç›®å½•ä¸‹
- [evpp/EventLoop_test.cpp](../evpp/EventLoop_test.cpp)
- [evpp/EventLoopThread_test.cpp](../evpp/EventLoopThread_test.cpp)
- [evpp/EventLoopThreadPool_test.cpp](../evpp/EventLoopThreadPool_test.cpp)

å¤šè¯´ä¸¤å¥ï¼š
- `EventLoop`ä¸­å®ç°äº†`muduo`æœ‰çš„ä¸¤ä¸ªæ¥å£ï¼Œ`runInLoop`å’Œ`queueInLoop`ï¼Œæˆ‘è§‰å¾—å‘½åä¸é”™ï¼Œä¹Ÿç›´æ¥é‡‡ç”¨äº†ã€‚`runInLoop`å¯¹åº”`SendMessage`ï¼Œ`queueInLoop`å¯¹åº”`PostMessage`ï¼Œè¿™ä¹ˆè§£é‡Šå¤§å®¶æ˜¯ä¸æ˜¯æ›´ç†è§£æ–‡ç« å¼€å¤´çš„é“ºå«äº†;
- `EventLoopThreadPool`çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯`one loop per thread`;


------

# libhvæ•™ç¨‹06--åˆ›å»ºä¸€ä¸ªç®€å•çš„TCPæœåŠ¡ç«¯

ä¸‹æ–‡ä»¥`TCP echo server`ä¸ºä¾‹ï¼Œä½¿ç”¨libhvåˆ›å»ºTCPæœåŠ¡ç«¯ã€‚

## cç‰ˆæœ¬
```c
#include "hv/hloop.h"

void on_close(hio_t* io) {
}

void on_recv(hio_t* io, void* buf, int readbytes) {
    // å›æ˜¾æ•°æ®
    hio_write(io, buf, readbytes);
}

void on_accept(hio_t* io) {
    // è®¾ç½®closeå›è°ƒ
    hio_setcb_close(io, on_close);
    // è®¾ç½®readå›è°ƒ
    hio_setcb_read(io, on_recv);
    // å¼€å§‹è¯»
    hio_read(io);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: cmd port\n");
        return -10;
    }
    int port = atoi(argv[1]);

    // åˆ›å»ºäº‹ä»¶å¾ªç¯
    hloop_t* loop = hloop_new(0);
    // åˆ›å»ºTCPæœåŠ¡
    hio_t* listenio = hloop_create_tcp_server(loop, "0.0.0.0", port, on_accept);
    if (listenio == NULL) {
        return -20;
    }
    // è¿è¡Œäº‹ä»¶å¾ªç¯
    hloop_run(loop);
    // é‡Šæ”¾äº‹ä»¶å¾ªç¯
    hloop_free(&loop);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
$ cc examples/tcp_echo_server.c -o bin/tcp_echo_server -I/usr/local/include/hv -lhv
$ bin/tcp_echo_server 1234
```
ç±»unixç³»ç»Ÿå¯ä½¿ç”¨ncä½œä¸ºå®¢æˆ·ç«¯æµ‹è¯•ï¼š
```shell
$ nc 127.0.0.1 1234
< hello
> hello
```

windowsç«¯å¯ä½¿ç”¨telnetä½œä¸ºå®¢æˆ·ç«¯æµ‹è¯•ï¼š
```shell
$ telent 127.0.0.1 1234
```

æ›´å¤šTCPæœåŠ¡ç«¯ç¤ºä¾‹å‚è€ƒï¼š
- [TCPå›æ˜¾æœåŠ¡](../examples/tcp_echo_server.c)
- [TCPèŠå¤©æœåŠ¡](../examples/tcp_chat_server.c)
- [TCPä»£ç†æœåŠ¡](../examples/tcp_proxy_server.c)

## c++ç‰ˆæœ¬
ä»£ç ç¤ºä¾‹å‚è€ƒ[evpp/TcpServer_test.cpp](../evpp/TcpServer_test.cpp)

```cpp
#include "hv/TcpServer.h"

using namespace hv;

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    TcpServer srv;
    int listenfd = srv.createsocket(port);
    if (listenfd < 0) {
        return -20;
    }
    printf("server listen on port %d, listenfd=%d ...\n", port, listenfd);
    srv.onConnection = [](const SocketChannelPtr& channel) {
        std::string peeraddr = channel->peeraddr();
        if (channel->isConnected()) {
            printf("%s connected! connfd=%d\n", peeraddr.c_str(), channel->fd());
        } else {
            printf("%s disconnected! connfd=%d\n", peeraddr.c_str(), channel->fd());
        }
    };
    srv.onMessage = [](const SocketChannelPtr& channel, Buffer* buf) {
        // echo
        printf("< %.*s\n", (int)buf->size(), (char*)buf->data());
        channel->write(buf);
    };
    srv.onWriteComplete = [](const SocketChannelPtr& channel, Buffer* buf) {
        printf("> %.*s\n", (int)buf->size(), (char*)buf->data());
    };
    srv.setThreadNum(4);
    srv.start();

    while (1) sleep(1);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
$ c++ -std=c++11 evpp/TcpServer_test.cpp -o bin/TcpServer_test -I/usr/local/include/hv -lhv
$ bin/TcpServer_test 5678
```
`TcpServer`æ›´å¤šå®ç”¨æ¥å£

- `setThreadNum`ï¼šè®¾ç½®IOçº¿ç¨‹æ•°
- `setMaxConnectionNum`ï¼šè®¾ç½®æœ€å¤§è¿æ¥æ•°
- `setUnpack`ï¼šè®¾ç½®æ‹†åŒ…
- `withTLS`ï¼šSSL/TLSåŠ å¯†é€šä¿¡

------

# libhvæ•™ç¨‹07--åˆ›å»ºä¸€ä¸ªç®€å•çš„TCPå®¢æˆ·ç«¯

## cç‰ˆæœ¬
```c
#include "hv/hloop.h"
#include "hv/htime.h"

void on_timer(htimer_t* timer) {
    char str[DATETIME_FMT_BUFLEN] = {0};
    datetime_t dt = datetime_now();
    datetime_fmt(&dt, str);

    printf("> %s\n", str);
    // è·å–userdata
    hio_t* io = (hio_t*)hevent_userdata(timer);
    // å‘é€å½“å‰æ—¶é—´å­—ç¬¦ä¸²
    hio_write(io, str, strlen(str));
}

void on_close(hio_t* io) {
}

void on_recv(hio_t* io, void* buf, int readbytes) {
    printf("< %.*s\n", readbytes, (char*)buf);
}

void on_connect(hio_t* io) {
    // è®¾ç½®closeå›è°ƒ
    hio_setcb_close(io, on_close);
    // è®¾ç½®readå›è°ƒ
    hio_setcb_read(io, on_recv);
    // å¼€å§‹è¯»
    hio_read(io);

    // æ·»åŠ ä¸€ä¸ªå®šæ—¶å™¨
    htimer_t* timer = htimer_add(hevent_loop(io), on_timer, 1000, INFINITE);
    // è®¾ç½®userdata
    hevent_set_userdata(timer, io);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: cmd port\n");
        return -10;
    }
    int port = atoi(argv[1]);

    // åˆ›å»ºäº‹ä»¶å¾ªç¯
    hloop_t* loop = hloop_new(0);
    // åˆ›å»ºTCPå®¢æˆ·ç«¯
    hio_t* listenio = hloop_create_tcp_client(loop, "127.0.0.1", port, on_connect);
    if (listenio == NULL) {
        return -20;
    }
    // è¿è¡Œäº‹ä»¶å¾ªç¯
    hloop_run(loop);
    // é‡Šæ”¾äº‹ä»¶å¾ªç¯
    hloop_free(&loop);
    return 0;
}
```
å®Œæ•´TCP/UDPå®¢æˆ·ç«¯ç¨‹åºå¯å‚è€ƒ[examples/nc.c](../examples/nc.c)

## c++ç‰ˆæœ¬
ç¤ºä¾‹ä»£ç è§ï¼š[evpp/TcpClient_test.cpp](../evpp/TcpClient_test.cpp)
```cpp
#include "hv/TcpClient.h"
#include "hv/htime.h"

using namespace hv;

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    TcpClient cli;
    int connfd = cli.createsocket(port);
    if (connfd < 0) {
        return -20;
    }
    printf("client connect to port %d, connfd=%d ...\n", port, connfd);
    cli.onConnection = [](const SocketChannelPtr& channel) {
        std::string peeraddr = channel->peeraddr();
        if (channel->isConnected()) {
            printf("connected to %s! connfd=%d\n", peeraddr.c_str(), channel->fd());
            // send(time) every 3s
            setInterval(3000, [channel](TimerID timerID){
                if (channel->isConnected()) {
                    char str[DATETIME_FMT_BUFLEN] = {0};
                    datetime_t dt = datetime_now();
                    datetime_fmt(&dt, str);
                    channel->write(str);
                } else {
                    killTimer(timerID);
                }
            });
        } else {
            printf("disconnected to %s! connfd=%d\n", peeraddr.c_str(), channel->fd());
        }
    };
    cli.onMessage = [](const SocketChannelPtr& channel, Buffer* buf) {
        printf("< %.*s\n", (int)buf->size(), (char*)buf->data());
    };
    cli.onWriteComplete = [](const SocketChannelPtr& channel, Buffer* buf) {
        printf("> %.*s\n", (int)buf->size(), (char*)buf->data());
    };
    // reconnect: 1,2,4,8,10,10,10...
    ReconnectInfo reconn;
    reconn.min_delay = 1000;
    reconn.max_delay = 10000;
    reconn.delay_policy = 2;
    cli.setReconnect(&reconn);
    cli.start();

    while (1) sleep(1);
    return 0;
}
```

`TcpClient`æ›´å¤šå®ç”¨æ¥å£

- `setConnectTimeout`ï¼šè®¾ç½®è¿æ¥è¶…æ—¶
- `setReconnect`ï¼šè®¾ç½®é‡è¿
- `setUnpack`: è®¾ç½®æ‹†åŒ…
- `withTLS`ï¼šSSL/TLSåŠ å¯†é€šä¿¡

------

# libhvæ•™ç¨‹08--åˆ›å»ºä¸€ä¸ªç®€å•çš„UDPæœåŠ¡ç«¯

ä¸‹æ–‡ä»¥`UDP echo server`ä¸ºä¾‹ï¼Œä½¿ç”¨libhvåˆ›å»ºUDPæœåŠ¡ç«¯ã€‚

## cç‰ˆæœ¬
ä»£ç ç¤ºä¾‹å‚è€ƒ[examples/udp_echo_server.c](../examples/udp_echo_server.c)
```c
#include "hv/hloop.h"
#include "hv/hsocket.h"

static void on_recvfrom(hio_t* io, void* buf, int readbytes) {
    printf("on_recvfrom fd=%d readbytes=%d\n", hio_fd(io), readbytes);
    char localaddrstr[SOCKADDR_STRLEN] = {0};
    char peeraddrstr[SOCKADDR_STRLEN] = {0};
    printf("[%s] <=> [%s]\n",
            SOCKADDR_STR(hio_localaddr(io), localaddrstr),
            SOCKADDR_STR(hio_peeraddr(io), peeraddrstr));
    printf("< %.*s", readbytes, (char*)buf);
    // å›æ˜¾æ•°æ®
    printf("> %.*s", readbytes, (char*)buf);
    hio_write(io, buf, readbytes);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    // åˆ›å»ºäº‹ä»¶å¾ªç¯
    hloop_t* loop = hloop_new(0);
    // åˆ›å»ºUDPæœåŠ¡
    hio_t* io = hloop_create_udp_server(loop, "0.0.0.0", port);
    if (io == NULL) {
        return -20;
    }
    // è®¾ç½®readå›è°ƒ
    hio_setcb_read(io, on_recvfrom);
    // å¼€å§‹è¯»
    hio_read(io);
    // è¿è¡Œäº‹ä»¶å¾ªç¯
    hloop_run(loop);
    // é‡Šæ”¾äº‹ä»¶å¾ªç¯
    hloop_free(&loop);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
$ cc examples/udp_echo_server.c -o bin/udp_echo_server -I/usr/local/include/hv -lhv
$ bin/udp_echo_server 1234
```
å¯ä½¿ç”¨ncä½œä¸ºå®¢æˆ·ç«¯æµ‹è¯•ï¼š
```shell
$ nc -u 127.0.0.1 1234
< hello
> hello
```

## c++ç‰ˆæœ¬
ä»£ç ç¤ºä¾‹å‚è€ƒ[evpp/UdpServer_test.cpp](../evpp/UdpServer_test.cpp)

```cpp
#include "hv/UdpServer.h"

using namespace hv;

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    UdpServer srv;
    int bindfd = srv.createsocket(port);
    if (bindfd < 0) {
        return -20;
    }
    printf("server bind on port %d, bindfd=%d ...\n", port, bindfd);
    srv.onMessage = [](const SocketChannelPtr& channel, Buffer* buf) {
        // echo
        printf("< %.*s\n", (int)buf->size(), (char*)buf->data());
        channel->write(buf);
    };
    srv.onWriteComplete = [](const SocketChannelPtr& channel, Buffer* buf) {
        printf("> %.*s\n", (int)buf->size(), (char*)buf->data());
    };
    srv.start();

    while (1) sleep(1);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
$ c++ -std=c++11 evpp/UdpServer_test.cpp -o bin/UdpServer_test -I/usr/local/include/hv -lhv
$ bin/UdpServer_test 5678
```

-------

# libhvæ•™ç¨‹09--åˆ›å»ºä¸€ä¸ªç®€å•çš„UDPå®¢æˆ·ç«¯

## cç‰ˆæœ¬
```c
#include "hv/hloop.h"
#include "hv/htime.h"

void on_timer(htimer_t* timer) {
    char str[DATETIME_FMT_BUFLEN] = {0};
    datetime_t dt = datetime_now();
    datetime_fmt(&dt, str);

    printf("> %s\n", str);
    // è·å–userdata
    hio_t* io = (hio_t*)hevent_userdata(timer);
    // å‘é€æ—¶é—´å­—ç¬¦ä¸²
    hio_write(io, str, strlen(str));
}

void on_recvfrom(hio_t* io, void* buf, int readbytes) {
    printf("< %.*s\n", readbytes, (char*)buf);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: cmd port\n");
        return -10;
    }
    int port = atoi(argv[1]);

    // åˆ›å»ºäº‹ä»¶å¾ªç¯
    hloop_t* loop = hloop_new(0);
    // åˆ›å»ºUDPå®¢æˆ·ç«¯
    hio_t* io = hloop_create_udp_client(loop, "127.0.0.1", port);
    if (io == NULL) {
        return -20;
    }
    // è®¾ç½®readå›è°ƒ
    hio_setcb_read(io, on_recvfrom);
    // å¼€å§‹è¯»
    hio_read(io);
    // æ·»åŠ ä¸€ä¸ªå®šæ—¶å™¨
    htimer_t* timer = htimer_add(hevent_loop(io), on_timer, 1000, INFINITE);
    // è®¾ç½®userdata
    hevent_set_userdata(timer, io);
    // è¿è¡Œäº‹ä»¶å¾ªç¯
    hloop_run(loop);
    // é‡Šæ”¾äº‹ä»¶å¾ªç¯
    hloop_free(&loop);
    return 0;
}
```
å®Œæ•´TCP/UDPå®¢æˆ·ç«¯ç¨‹åºå¯å‚è€ƒ[examples/nc.c](../examples/nc.c)

## c++ç‰ˆæœ¬
ç¤ºä¾‹ä»£ç è§ï¼š[evpp/UdpClient_test.cpp](../evpp/UdpClient_test.cpp)
```cpp
#include "hv/UdpClient.h"
#include "hv/htime.h"

using namespace hv;

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    UdpClient cli;
    int sockfd = cli.createsocket(port);
    if (sockfd < 0) {
        return -20;
    }
    printf("client sendto port %d, sockfd=%d ...\n", port, sockfd);
    cli.onMessage = [](const SocketChannelPtr& channel, Buffer* buf) {
        printf("< %.*s\n", (int)buf->size(), (char*)buf->data());
    };
    cli.onWriteComplete = [](const SocketChannelPtr& channel, Buffer* buf) {
        printf("> %.*s\n", (int)buf->size(), (char*)buf->data());
    };
    cli.start();

    // sendto(time) every 3s
    cli.loop()->setInterval(3000, [&cli](TimerID timerID) {
        char str[DATETIME_FMT_BUFLEN] = {0};
        datetime_t dt = datetime_now();
        datetime_fmt(&dt, str);
        cli.sendto(str);
    });

    while (1) sleep(1);
    return 0;
}
```

------

# libhvæ•™ç¨‹10--åˆ›å»ºä¸€ä¸ªç®€å•çš„HTTPæœåŠ¡ç«¯

HTTPåè®®ä½œä¸ºæœ¬ä¸–çºªæœ€é€šç”¨çš„åº”ç”¨å±‚åè®®ï¼Œæœ¬æ–‡å°±ä¸åŠ ä»¥ä»‹ç»äº†ï¼Œä¸ç†Ÿæ‚‰çš„è‡ªè¡Œé˜…è¯»[awesome-http](https://github.com/semlinker/awesome-http)

## ç®€å•çš„HTTPæœåŠ¡ç«¯ç¤ºä¾‹

ç¤ºä¾‹ä»£ç å‚è€ƒ[examples/http_server_test.cpp](../examples/http_server_test.cpp)
```cpp
#include "hv/HttpServer.h"

int main() {
    HttpService router;
    router.GET("/ping", [](HttpRequest* req, HttpResponse* resp) {
        return resp->String("pong");
    });

    router.GET("/data", [](HttpRequest* req, HttpResponse* resp) {
        static char data[] = "0123456789";
        return resp->Data(data, 10);
    });

    router.GET("/paths", [&router](HttpRequest* req, HttpResponse* resp) {
        return resp->Json(router.Paths());
    });

    router.POST("/echo", [](const HttpContextPtr& ctx) {
        return ctx->send(ctx->body(), ctx->type());
    });

    http_server_t server;
    server.port = 8080;
    server.service = &router;
    http_server_run(&server);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
c++ -std=c++11 examples/http_server_test.cpp -o bin/http_server_test -lhv
bin/http_server_test
```
æµ‹è¯•ä½¿ç”¨`curl`æˆ–æµè§ˆå™¨è¾“å…¥ä»¥ä¸‹`url`ï¼š
```shell
curl -v http://127.0.0.1:8080/ping
curl -v http://127.0.0.1:8080/data
curl -v http://127.0.0.1:8080/paths
curl -v http://127.0.0.1:8080/echo -d "hello,world"
```

## å®Œæ•´çš„HTTPæœåŠ¡ç«¯ç¤ºä¾‹
å®Œæ•´çš„httpæœåŠ¡ç«¯ç¤ºä¾‹ä»£ç å‚è€ƒ[examples/httpd](https://github.com/ithewei/libhv/tree/master/examples/httpd)
æµ‹è¯•æ­¥éª¤:
```shell
git clone https://github.com/ithewei/libhv.git
cd libhv
make httpd curl

bin/httpd -h
bin/httpd -d
#bin/httpd -c etc/httpd.conf -s restart -d
ps aux | grep httpd

# http web service
bin/curl -v localhost:8080

# http indexof service
bin/curl -v localhost:8080/downloads/

# http api service
bin/curl -v localhost:8080/ping
bin/curl -v localhost:8080/echo -d "hello,world!"
bin/curl -v localhost:8080/query?page_no=1\&page_size=10
bin/curl -v localhost:8080/kv   -H "Content-Type:application/x-www-form-urlencoded" -d 'user=admin&pswd=123456'
bin/curl -v localhost:8080/json -H "Content-Type:application/json" -d '{"user":"admin","pswd":"123456"}'
bin/curl -v localhost:8080/form -F "user=admin pswd=123456"
bin/curl -v localhost:8080/upload -F "file=@LICENSE"

bin/curl -v localhost:8080/test -H "Content-Type:application/x-www-form-urlencoded" -d 'bool=1&int=123&float=3.14&string=hello'
bin/curl -v localhost:8080/test -H "Content-Type:application/json" -d '{"bool":true,"int":123,"float":3.14,"string":"hello"}'
bin/curl -v localhost:8080/test -F 'bool=1 int=123 float=3.14 string=hello'
# RESTful API: /group/:group_name/user/:user_id
bin/curl -v -X DELETE localhost:8080/group/test/user/123
```

## å‹åŠ›æµ‹è¯•
ä½¿ç”¨`apache`çš„`ab`ã€æˆ–è€…`wrk`éƒ½å¯ä»¥ç”¨æ¥åšå‹åŠ›æµ‹è¯•ï¼Œä¸€èˆ¬æœåŠ¡å™¨å•çº¿ç¨‹`QPS`å¯è½»æ¾è¾¾åˆ°`3w`
```bash
# sudo apt install apache2-utils
ab -c 100 -n 100000 http://127.0.0.1:8080/

# sudo apt install wrk
wrk -c 100 -t 4 -d 10s http://127.0.0.1:8080/
```
æ›´å¤šHTTPå‹åŠ›æµ‹è¯•å·¥å…·å‚è€ƒ[awesome-http-benchmark](https://github.com/denji/awesome-http-benchmark)

------

# libhvæ•™ç¨‹11--åˆ›å»ºä¸€ä¸ªç®€å•çš„HTTPå®¢æˆ·ç«¯

## ç®€å•çš„åŒæ­¥HTTPå®¢æˆ·ç«¯ç¤ºä¾‹
åŒæ­¥httpå®¢æˆ·ç«¯æ¥å£æ¨¡æ‹Ÿå®ç°äº†`python`çš„`requests`
```cpp
#include "requests.h"

int main() {
    auto resp = requests::get("http://www.example.com");
    if (resp == NULL) {
        printf("request failed!\n");
    } else {
        printf("%d %s\r\n", resp->status_code, resp->status_message());
        printf("%s\n", resp->body.c_str());
    }

    resp = requests::post("127.0.0.1:8080/echo", "hello,world!");
    if (resp == NULL) {
        printf("request failed!\n");
    } else {
        printf("%d %s\r\n", resp->status_code, resp->status_message());
        printf("%s\n", resp->body.c_str());
    }

    return 0;
}
```
## ç®€å•çš„å¼‚æ­¥HTTPå®¢æˆ·ç«¯ç¤ºä¾‹
ç¤ºä¾‹ä»£ç å‚è€ƒ[examples/http_client_test.cpp](../examples/http_client_test.cpp)
```cpp
#include "requests.h"

#include "hthread.h" // import hv_gettid

static void test_http_async_client(int* finished) {
    printf("test_http_async_client request thread tid=%ld\n", hv_gettid());
    HttpRequestPtr req(new HttpRequest);
    req->method = HTTP_POST;
    req->url = "127.0.0.1:8080/echo";
    req->headers["Connection"] = "keep-alive";
    req->body = "this is an async request.";
    req->timeout = 10;
    http_client_send_async(req, [finished](const HttpResponsePtr& resp) {
        printf("test_http_async_client response thread tid=%ld\n", hv_gettid());
        if (resp == NULL) {
            printf("request failed!\n");
        } else {
            printf("%d %s\r\n", resp->status_code, resp->status_message());
            printf("%s\n", resp->body.c_str());
        }
        *finished = 1;
    });
}

int main() {
    int finished = 0;
    test_http_async_client(&finished);

    // demo wait async ResponseCallback
    while (!finished) {
        hv_delay(100);
    }
    printf("finished!\n");

    return 0;
}
```
## å®Œæ•´çš„HTTPå®¢æˆ·ç«¯ç¤ºä¾‹
å®Œæ•´çš„httpå®¢æˆ·ç«¯ç¤ºä¾‹ä»£ç å‚è€ƒ[examples/curl.cpp](https://github.com/ithewei/libhv/tree/master/examples/curl.cpp)ï¼Œæ¨¡æ‹Ÿå®ç°äº†`curl`å‘½ä»¤è¡Œç¨‹åºã€‚

æµ‹è¯•æ­¥éª¤:
```shell
git clone https://github.com/ithewei/libhv.git
cd libhv
make httpd curl

bin/httpd -h
bin/httpd -d
#bin/httpd -c etc/httpd.conf -s restart -d
ps aux | grep httpd

# http web service
bin/curl -v localhost:8080

# http indexof service
bin/curl -v localhost:8080/downloads/

# http api service
bin/curl -v localhost:8080/ping
bin/curl -v localhost:8080/echo -d "hello,world!"
bin/curl -v localhost:8080/query?page_no=1\&page_size=10
bin/curl -v localhost:8080/kv   -H "Content-Type:application/x-www-form-urlencoded" -d 'user=admin&pswd=123456'
bin/curl -v localhost:8080/json -H "Content-Type:application/json" -d '{"user":"admin","pswd":"123456"}'
bin/curl -v localhost:8080/form -F "user=admin pswd=123456"
bin/curl -v localhost:8080/upload -F "file=@LICENSE"

bin/curl -v localhost:8080/test -H "Content-Type:application/x-www-form-urlencoded" -d 'bool=1&int=123&float=3.14&string=hello'
bin/curl -v localhost:8080/test -H "Content-Type:application/json" -d '{"bool":true,"int":123,"float":3.14,"string":"hello"}'
bin/curl -v localhost:8080/test -F 'bool=1 int=123 float=3.14 string=hello'
# RESTful API: /group/:group_name/user/:user_id
bin/curl -v -X DELETE localhost:8080/group/test/user/123
```

æ›´å¤šHTTPæ¶ˆæ¯ä½¿ç”¨æ–¹å¼è¯·é˜…è¯»å¤´æ–‡ä»¶[HttpMessage.h](../http/HttpMessage.h)

------

# libhvæ•™ç¨‹12--åˆ›å»ºä¸€ä¸ªç®€å•çš„WebSocketæœåŠ¡ç«¯

ç¤ºä¾‹ä»£ç å‚è€ƒ[examples/websocket_server_test.cpp](../examples/websocket_server_test.cpp)
```cpp
#include "WebSocketServer.h"
#include "EventLoop.h"
#include "htime.h"

using namespace hv;

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    WebSocketService ws;
    ws.onopen = [](const WebSocketChannelPtr& channel, const std::string& url) {
        printf("onopen: GET %s\n", url.c_str());
        // send(time) every 1s
        setInterval(1000, [channel](TimerID id) {
            if (channel->isConnected()) {
                char str[DATETIME_FMT_BUFLEN] = {0};
                datetime_t dt = datetime_now();
                datetime_fmt(&dt, str);
                channel->send(str);
            } else {
                killTimer(id);
            }
        });
    };
    ws.onmessage = [](const WebSocketChannelPtr& channel, const std::string& msg) {
        printf("onmessage: %s\n", msg.c_str());
    };
    ws.onclose = [](const WebSocketChannelPtr& channel) {
        printf("onclose\n");
    };

    websocket_server_t server;
    server.port = port;
    server.ws = &ws;
    websocket_server_run(&server);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
c++ -std=c++11 examples/websocket_server_test.cpp -o bin/websocket_server_test -I/usr/local/include/hv -lhv
bin/websocket_server_test 8888
```
æµ‹è¯•å®¢æˆ·ç«¯å¯ä½¿ç”¨[html/websocket_client.html](../html/websocket_client.html)
æˆ–è€…[websocketåœ¨çº¿æµ‹è¯•](http://www.websocket-test.com/)

------

# libhvæ•™ç¨‹13--åˆ›å»ºä¸€ä¸ªç®€å•çš„WebSocketå®¢æˆ·ç«¯

## WebSocketç®€ä»‹
### WebSocket äº§ç”ŸèƒŒæ™¯

åœ¨ WebSocket åè®®å‡ºç°ä»¥å‰ï¼Œåˆ›å»ºä¸€ä¸ªå’ŒæœåŠ¡ç«¯è¿›è¡ŒåŒé€šé“é€šä¿¡çš„ web åº”ç”¨ï¼Œéœ€è¦ä¾èµ–HTTPåè®®è¿›è¡Œä¸åœçš„è½®è¯¢ï¼Œè¿™ä¼šå¯¼è‡´ä¸€äº›é—®é¢˜ï¼š

- æœåŠ¡ç«¯è¢«è¿«ç»´æŒæ¥è‡ªæ¯ä¸ªå®¢æˆ·ç«¯çš„å¤§é‡ä¸åŒçš„è¿æ¥
- å¤§é‡çš„è½®è¯¢è¯·æ±‚ä¼šé€ æˆé«˜å¼€é”€ï¼Œæ¯”å¦‚ä¼šå¸¦ä¸Šå¤šä½™çš„headerï¼Œé€ æˆäº†æ— ç”¨çš„æ•°æ®ä¼ è¾“

æ‰€ä»¥ï¼Œä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼ŒWebSocket åè®®åº”è¿è€Œç”Ÿã€‚

### WebSocket çš„å®šä¹‰

WebSocket æ˜¯ä¸€ç§åœ¨å•ä¸ªTCPè¿æ¥ä¸Šè¿›è¡Œå…¨åŒå·¥é€šä¿¡çš„åè®®ã€‚WebSocket ä½¿å¾—å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´çš„æ•°æ®äº¤æ¢å˜å¾—æ›´åŠ ç®€å•ï¼Œå…è®¸æœåŠ¡ç«¯ä¸»åŠ¨å‘å®¢æˆ·ç«¯æ¨é€æ•°æ®ã€‚

åœ¨ WebSocket API ä¸­ï¼Œæµè§ˆå™¨å’ŒæœåŠ¡å™¨åªéœ€è¦å®Œæˆä¸€æ¬¡æ¡æ‰‹ï¼Œä¸¤è€…ä¹‹é—´å°±ç›´æ¥å¯ä»¥åˆ›å»ºæŒä¹…æ€§çš„è¿æ¥ï¼Œ å¹¶è¿›è¡ŒåŒå‘æ•°æ®ä¼ è¾“ã€‚

### WebSocket æ¡æ‰‹è¿‡ç¨‹

å®¢æˆ·ç«¯è¯·æ±‚
```shell
GET / HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: example.com
Origin: http://example.com
Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==
Sec-WebSocket-Version: 13
```
æœåŠ¡å™¨å›åº”
```shell
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=
Sec-WebSocket-Location: ws://example.com/
```

### WebSocket é€šä¿¡åè®®
WebSocket é€šä¿¡åè®®æœ¬æ–‡å±…äºç¯‡å¹…ï¼Œå°±ä¸å±•å¼€è¯´æ˜ï¼Œæ„Ÿå…´è¶£çš„æ¨èé˜…è¯»ä¸‹é¢è¿™ç¯‡åšæ–‡ï¼š

[WebSocketåè®®ï¼š5åˆ†é’Ÿä»å…¥é—¨åˆ°ç²¾é€š](https://www.cnblogs.com/chyingp/p/websocket-deep-in.html
)
## ç¤ºä¾‹ä»£ç 
### jsç¤ºä¾‹ä»£ç 
è§ [html/websocket_client.html](../html/websocket_client.html)
```js
function WebSocketTest(url) {
    var ws = new WebSocket(url);
    
    ws.onopen = function() {
        alert("è¿æ¥å·²å»ºç«‹");
        ws.send("hello");
    };

    ws.onmessage = function(ev) {
        var received_msg = ev.data;
        console.log("received websocket message: " + received_msg);
    };

    ws.onclose = function() {
        alert("è¿æ¥å·²å…³é—­");
    };
}
```

### c++ç¤ºä¾‹ä»£ç 
libhvæä¾›çš„`WebSocketClient`ç±»ä½¿ç”¨èµ·æ¥ä¸JSçš„`WebSocket`ä¸€æ ·ç®€å•ã€‚

ç¤ºä¾‹ä»£ç è§ [examples/websocket_client_test.cpp](../examples/websocket_client_test.cpp)
```cpp
#include "WebSocketClient.h"

using namespace hv;

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s url\n", argv[0]);
        return -10;
    }
    const char* url = argv[1];

    WebSocketClient ws;
    ws.onopen = [&ws]() {
        printf("onopen\n");
        ws.send("hello");
    };
    ws.onclose = []() {
        printf("onclose\n");
    };
    ws.onmessage = [](const std::string& msg) {
        printf("onmessage: %s\n", msg.c_str());
    };

    // reconnect: 1,2,4,8,10,10,10...
    ReconnectInfo reconn;
    reconn.min_delay = 1000;
    reconn.max_delay = 10000;
    reconn.delay_policy = 2;
    ws.setReconnect(&reconn);

    ws.open(url);

    while (1) hv_delay(1000);
    return 0;
}
```
ç¼–è¯‘è¿è¡Œï¼š
```shell
c++ -std=c++11 examples/websocket_client_test.cpp -o bin/websocket_client_test -I/usr/local/include/hv -lhv
bin/websocket_client_test ws://127.0.0.1:8888/
```

------

# libhvæ•™ç¨‹14--200è¡Œå®ç°ä¸€ä¸ªçº¯Cç‰ˆjsonrpcæ¡†æ¶

ä½¿ç”¨libhvå¯ä»¥åœ¨200è¡Œå†…å®ç°ä¸€ä¸ªå®Œæ•´çš„jsonrpcæ¡†æ¶ï¼Œè¿™å¾—ç›Šäºlibhvæ–°æä¾›çš„ä¸€ä¸ªæ¥å£
`hio_set_unpack`è®¾ç½®æ‹†åŒ…è§„åˆ™ï¼Œæ”¯æŒ`å›ºå®šåŒ…é•¿ã€åˆ†éš”ç¬¦ã€å¤´éƒ¨é•¿åº¦å­—æ®µ`ä¸‰ç§å¸¸è§çš„æ‹†åŒ…æ–¹å¼ï¼Œè°ƒç”¨è¯¥æ¥å£è®¾ç½®æ‹†åŒ…è§„åˆ™åï¼Œå†…éƒ¨ä¼šæ ¹æ®æ‹†åŒ…è§„åˆ™å¤„ç†ç²˜åŒ…ä¸åˆ†åŒ…ï¼Œä¿è¯å›è°ƒä¸Šæ¥çš„æ˜¯å®Œæ•´çš„ä¸€åŒ…æ•°æ®ï¼Œå¤§å¤§èŠ‚çœäº†ä¸Šå±‚å¤„ç†ç²˜åŒ…ä¸åˆ†åŒ…çš„æˆæœ¬ï¼Œè¯¥æ¥å£å…·ä½“å®šä¹‰å¦‚ä¸‹ï¼š
```c
typedef enum {
    UNPACK_BY_FIXED_LENGTH  = 1,    // æ ¹æ®å›ºå®šé•¿åº¦æ‹†åŒ…
    UNPACK_BY_DELIMITER     = 2,    // æ ¹æ®åˆ†éš”ç¬¦æ‹†åŒ…ï¼Œå¦‚å¸¸è§çš„â€œ\r\nâ€
    UNPACK_BY_LENGTH_FIELD  = 3,    // æ ¹æ®å¤´éƒ¨é•¿åº¦å­—æ®µæ‹†åŒ…
} unpack_mode_e;

#define DEFAULT_PACKAGE_MAX_LENGTH  (1 << 21)   // 2M

// UNPACK_BY_DELIMITER
#define PACKAGE_MAX_DELIMITER_BYTES 8

// UNPACK_BY_LENGTH_FIELD
typedef enum {
    ENCODE_BY_VARINT        = 1,                // varintç¼–ç 
    ENCODE_BY_LITTEL_ENDIAN = LITTLE_ENDIAN,    // å°ç«¯ç¼–ç 
    ENCODE_BY_BIG_ENDIAN    = BIG_ENDIAN,       // å¤§ç«¯ç¼–ç 
} unpack_coding_e;

typedef struct unpack_setting_s {
    unpack_mode_e   mode; // æ‹†åŒ…æ¨¡å¼
    unsigned int    package_max_length; // æœ€å¤§åŒ…é•¿åº¦é™åˆ¶
    // UNPACK_BY_FIXED_LENGTH
    unsigned int    fixed_length; // å›ºå®šåŒ…é•¿åº¦
    // UNPACK_BY_DELIMITER
    unsigned char   delimiter[PACKAGE_MAX_DELIMITER_BYTES]; // åˆ†éš”ç¬¦
    unsigned short  delimiter_bytes; // åˆ†éš”ç¬¦é•¿åº¦
    // UNPACK_BY_LENGTH_FIELD
    unsigned short  body_offset; // bodyåç§»é‡ï¼ˆå³å¤´éƒ¨é•¿åº¦ï¼‰real_body_offset = body_offset + varint_bytes - length_field_bytes
    unsigned short  length_field_offset; // å¤´éƒ¨é•¿åº¦å­—æ®µåç§»é‡
    unsigned short  length_field_bytes; // å¤´éƒ¨é•¿åº¦å­—æ®µæ‰€å å­—èŠ‚æ•°
    unpack_coding_e length_field_coding; // å¤´éƒ¨é•¿åº¦å­—æ®µç¼–ç æ–¹å¼ï¼Œæ”¯æŒvarintã€å¤§å°ç«¯ä¸‰ç§ç¼–ç æ–¹å¼ï¼Œé€šå¸¸ä½¿ç”¨å¤§ç«¯å­—èŠ‚åºï¼ˆå³ç½‘ç»œå­—èŠ‚åºï¼‰
#ifdef __cplusplus
    unpack_setting_s() {
        // Recommended setting:
        // head = flags:1byte + length:4bytes = 5bytes
        mode = UNPACK_BY_LENGTH_FIELD;
        package_max_length = DEFAULT_PACKAGE_MAX_LENGTH;
        fixed_length = 0;
        delimiter_bytes = 0;
        body_offset = 5;
        length_field_offset = 1;
        length_field_bytes = 4;
        length_field_coding = ENCODE_BY_BIG_ENDIAN;
    }
#endif
} unpack_setting_t;

HV_EXPORT void hio_set_unpack(hio_t* io, unpack_setting_t* setting);
```
ä»¥`ftp`ä¸ºä¾‹ï¼ˆåˆ†éš”ç¬¦æ–¹å¼ï¼‰å¯ä»¥è¿™æ ·è®¾ç½®ï¼š
```c
unpack_setting_t ftp_unpack_setting;
memset(&ftp_unpack_setting, 0, sizeof(unpack_setting_t));
ftp_unpack_setting.package_max_length = DEFAULT_PACKAGE_MAX_LENGTH;
ftp_unpack_setting.mode = UNPACK_BY_DELIMITER;
ftp_unpack_setting.delimiter[0] = '\r';
ftp_unpack_setting.delimiter[1] = '\n';
ftp_unpack_setting.delimiter_bytes = 2;
```
ä»¥`mqtt`ä¸ºä¾‹ï¼ˆå¤´éƒ¨é•¿åº¦å­—æ®µæ–¹å¼ï¼‰å¯ä»¥è¿™æ ·è®¾ç½®ï¼š
```c
unpack_setting_t mqtt_unpack_setting = {
    .mode = UNPACK_BY_LENGTH_FIELD,
    .package_max_length = DEFAULT_PACKAGE_MAX_LENGTH,
    .body_offset = 2,
    .length_field_offset = 1,
    .length_field_bytes = 1,
    .length_field_coding = ENCODE_BY_VARINT,
};
```
å…·ä½“å®ç°ä»£ç åœ¨[event/unpack.c](../event/unpack.c)ä¸­ï¼Œåœ¨å†…éƒ¨`readbuf`çš„åŸºç¡€ä¸Šç›´æ¥åŸåœ°æ‹†åŒ…ä¸ç»„åŒ…ï¼ŒåŸºæœ¬åšåˆ°é›¶æ‹·è´ï¼Œæ¯”æŠ›ç»™ä¸Šå±‚å¤„ç†æ›´é«˜æ•ˆï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥ç ”ç©¶ä¸€ä¸‹ã€‚

## ç¤ºä¾‹ä»£ç 
è§[examples/jsonrpc](https://github.com/ithewei/libhv/tree/master/examples/jsonrpc)

```c
#include "hloop.h"
#include "hbase.h"
#include "hsocket.h"

#include "jsonrpc.h"
#include "cJSON.h"
#include "router.h"
#include "handler.h"

// hloop_create_tcp_server -> on_accept -> hio_read -> on_recv -> hio_write

static unpack_setting_t jsonrpc_unpack_setting;

jsonrpc_router router[] = {
    {"add", do_add},
    {"sub", do_sub},
    {"mul", do_mul},
    {"div", do_div},
};
#define JSONRPC_ROUTER_NUM  (sizeof(router)/sizeof(router[0]))

static void on_close(hio_t* io) {
    printf("on_close fd=%d error=%d\n", hio_fd(io), hio_error(io));
}

static void on_recv(hio_t* io, void* readbuf, int readbytes) {
    // unpack -> cJSON_Parse -> router -> cJSON_Print -> pack -> hio_write
    // unpack
    jsonrpc_message msg;
    memset(&msg, 0, sizeof(msg));
    int packlen = jsonrpc_unpack(&msg, readbuf, readbytes);
    if (packlen < 0) {
        printf("jsonrpc_unpack failed!\n");
        return;
    }
    assert(packlen == readbytes);

    // cJSON_Parse
    printf("> %.*s\n", msg.head.length, msg.body);
    cJSON* jreq = cJSON_ParseWithLength(msg.body, msg.head.length);
    cJSON* jres = cJSON_CreateObject();
    cJSON* jmethod = cJSON_GetObjectItem(jreq, "method");
    if (!jmethod || !cJSON_IsString(jmethod)) {
        bad_request(jreq, jres);
    } else {
        // router
        char* method = cJSON_GetStringValue(jmethod);
        bool found = false;
        for (int i = 0; i < JSONRPC_ROUTER_NUM; ++i) {
            if (strcmp(method, router[i].method) == 0) {
                found = true;
                router[i].handler(jreq, jres);
                break;
            }
        }
        if (!found) {
            not_found(jreq, jres);
        }
    }

    // cJSON_Print
    memset(&msg, 0, sizeof(msg));
    msg.body = cJSON_PrintUnformatted(jres);
    msg.head.length = strlen(msg.body);
    printf("< %.*s\n", msg.head.length, msg.body);

    // pack
    packlen = jsonrpc_package_length(&msg.head);
    unsigned char* writebuf = NULL;
    HV_ALLOC(writebuf, packlen);
    packlen = jsonrpc_pack(&msg, writebuf, packlen);
    if (packlen > 0) {
        hio_write(io, writebuf, packlen);
    }

    cJSON_Delete(jreq);
    cJSON_Delete(jres);
    cJSON_free((void*)msg.body);
    HV_FREE(writebuf);
}

static void on_accept(hio_t* io) {
    printf("on_accept connfd=%d\n", hio_fd(io));

    hio_setcb_close(io, on_close);
    hio_setcb_read(io, on_recv);
    hio_set_unpack(io, &jsonrpc_unpack_setting);
    hio_read(io);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    // init jsonrpc_unpack_setting
    memset(&jsonrpc_unpack_setting, 0, sizeof(unpack_setting_t));
    jsonrpc_unpack_setting.mode = UNPACK_BY_LENGTH_FIELD;
    jsonrpc_unpack_setting.package_max_length = DEFAULT_PACKAGE_MAX_LENGTH;
    jsonrpc_unpack_setting.body_offset = JSONRPC_HEAD_LENGTH;
    jsonrpc_unpack_setting.length_field_offset = 1;
    jsonrpc_unpack_setting.length_field_bytes = 4;
    jsonrpc_unpack_setting.length_field_coding = ENCODE_BY_BIG_ENDIAN;

    hloop_t* loop = hloop_new(0);
    hio_t* listenio = hloop_create_tcp_server(loop, "0.0.0.0", port, on_accept);
    if (listenio == NULL) {
        return -20;
    }
    printf("listenfd=%d\n", hio_fd(listenio));
    hloop_run(loop);
    hloop_free(&loop);
    return 0;
}
```

### å…³é”®å‡½æ•°
- hloop_newï¼šåˆ›å»ºäº‹ä»¶å¾ªç¯
- hloop_run: è¿è¡Œäº‹ä»¶å¾ªç¯
- hloop_create_tcp_serverï¼šåˆ›å»ºTCPæœåŠ¡
- <font color="red">hio_set_unpackï¼šè®¾ç½®æ‹†åŒ…è§„åˆ™</font>
- hio_readï¼šå¼€å§‹æ¥æ”¶æ•°æ®
- hio_write: å‘é€æ•°æ®
- jsonrpc_unpackï¼šæ‹†åŒ…
- jsonrpc_packï¼šç»„åŒ…
- cJSON_xxxï¼šjsonç¼–è§£ç 

## æµ‹è¯•æ­¥éª¤
```shell
git clone https://github.com/ithewei/libhv
cd libhv
make jsonrpc
# mkdir build && cd build && cmake .. && cmake --build . --target jsonrpc
bin/jsonrpc_server 1234
bin/jsonrpc_client 127.0.0.1 1234 add 1 2
bin/jsonrpc_client 127.0.0.1 1234 div 1 0
bin/jsonrpc_client 127.0.0.1 1234 xyz 1 2
```

ç»“æœå¦‚ä¸‹ï¼š
æœåŠ¡ç«¯ï¼š
```shell
$ bin/jsonrpc_server 1234
listenfd=4
on_accept connfd=7
> {"id":1,"method":"add","params":[1,2]}
< {"id":1,"result":3}
on_close fd=7 error=0
```

å®¢æˆ·ç«¯ï¼š
```shell
$ bin/jsonrpc_client 127.0.0.1 1234 add 1 2
on_connect fd=4
> {"id":1,"method":"add","params":[1,2]}
< {"id":1,"result":3}
on_close fd=4 error=0
```

```shell
$ bin/jsonrpc_client 127.0.0.1 1234 div 1 0
on_connect fd=4
> {"id":1,"method":"div","params":[1,0]}
< {"id":1,"error":{"code":400,"message":"Bad Request"}}
on_close fd=4 error=0
```

```shell
$ bin/jsonrpc_client 127.0.0.1 1234 xyz 1 2
on_connect fd=4
> {"id":1,"method":"xyz","params":[1,2]}
< {"id":1,"error":{"code":404,"message":"Not Found"}}
on_close fd=4 error=0
```

------

# libhvæ•™ç¨‹15--200è¡Œå®ç°ä¸€ä¸ªC++ç‰ˆprotorpcæ¡†æ¶

åœ¨ä¸Šç¯‡æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬200è¡Œå®ç°äº†ä¸€ä¸ª[çº¯Cç‰ˆçš„jsonrpcæ¡†æ¶](https://hewei.blog.csdn.net/article/details/119920540)ï¼Œä½¿ç”¨çš„`eventæ¨¡å—+cJSON`å®ç°ï¼Œæœ¬ç¯‡ä¸­æˆ‘ä»¬å°†ä»‹ç»200è¡Œå®ç°ä¸€ä¸ªC++ç‰ˆçš„protorpcæ¡†æ¶ï¼Œä½¿ç”¨`evppæ¨¡å—+protobuf`å®ç°ã€‚

evppæ¨¡å—æ˜¯eventæ¨¡å—çš„c++å°è£…ï¼Œå…·ä½“ä»‹ç»è§[evpp/README.md](../evpp/README.md)

protobufæ˜¯googleå‡ºå“çš„åºåˆ—åŒ–/ååºåˆ—åŒ–ç»“æ„åŒ–æ•°æ®å­˜å‚¨æ ¼å¼ï¼Œå…·ä½“ä»‹ç»å¯å‚è€ƒæˆ‘çš„å¦ä¸€ç¯‡åšå®¢[protobuf](https://hewei.blog.csdn.net/article/details/81506024)ï¼Œä¹Ÿå¯å‚è€ƒ[protobufå®˜æ–¹æ–‡æ¡£](https://developers.google.com/protocol-buffers/docs/overview)

## protobufå®‰è£…
```shell
git clone https://github.com/protocolbuffers/protobuf
cd protobuf
./autogen.sh
./configure
make
sudo make install
sudo ldconfig

which protoc
protoc -h
```

## protorpcä»£ç 
è§[exmaples/protorpc](https://github.com/ithewei/libhv/tree/master/examples/protorpc)

```cpp
#include "TcpServer.h"

using namespace hv;

#include "protorpc.h"
#include "router.h"
#include "handler/handler.h"
#include "handler/calc.h"
#include "handler/login.h"

protorpc_router router[] = {
    {"add", calc_add},
    {"sub", calc_sub},
    {"mul", calc_mul},
    {"div", calc_div},
    {"login", login},
};
#define PROTORPC_ROUTER_NUM  (sizeof(router)/sizeof(router[0]))

class ProtoRpcServer : public TcpServer {
public:
    ProtoRpcServer() : TcpServer()
    {
        onConnection = [](const SocketChannelPtr& channel) {
            std::string peeraddr = channel->peeraddr();
            if (channel->isConnected()) {
                printf("%s connected! connfd=%d\n", peeraddr.c_str(), channel->fd());
            } else {
                printf("%s disconnected! connfd=%d\n", peeraddr.c_str(), channel->fd());
            }
        };
        onMessage = handleMessage;
        // init protorpc_unpack_setting
        unpack_setting_t protorpc_unpack_setting;
        memset(&protorpc_unpack_setting, 0, sizeof(unpack_setting_t));
        protorpc_unpack_setting.mode = UNPACK_BY_LENGTH_FIELD;
        protorpc_unpack_setting.package_max_length = DEFAULT_PACKAGE_MAX_LENGTH;
        protorpc_unpack_setting.body_offset = PROTORPC_HEAD_LENGTH;
        protorpc_unpack_setting.length_field_offset = 1;
        protorpc_unpack_setting.length_field_bytes = 4;
        protorpc_unpack_setting.length_field_coding = ENCODE_BY_BIG_ENDIAN;
        setUnpack(&protorpc_unpack_setting);
    }

    int listen(int port) { return createsocket(port); }

private:
    static void handleMessage(const SocketChannelPtr& channel, Buffer* buf) {
        // unpack -> Request::ParseFromArray -> router -> Response::SerializeToArray -> pack -> Channel::write
        // protorpc_unpack
        protorpc_message msg;
        memset(&msg, 0, sizeof(msg));
        int packlen = protorpc_unpack(&msg, buf->data(), buf->size());
        if (packlen < 0) {
            printf("protorpc_unpack failed!\n");
            return;
        }
        assert(packlen == buf->size());

        // Request::ParseFromArray
        protorpc::Request req;
        protorpc::Response res;
        if (req.ParseFromArray(msg.body, msg.head.length)) {
            printf("> %s\n", req.DebugString().c_str());
            res.set_id(req.id());
            // router
            const char* method = req.method().c_str();
            bool found = false;
            for (int i = 0; i < PROTORPC_ROUTER_NUM; ++i) {
                if (strcmp(method, router[i].method) == 0) {
                    found = true;
                    router[i].handler(req, &res);
                    break;
                }
            }
            if (!found) {
                not_found(req, &res);
            }
        } else {
            bad_request(req, &res);
        }

        // Response::SerializeToArray + protorpc_pack
        memset(&msg, 0, sizeof(msg));
        msg.head.length = res.ByteSizeLong();
        packlen = protorpc_package_length(&msg.head);
        unsigned char* writebuf = NULL;
        HV_ALLOC(writebuf, packlen);
        packlen = protorpc_pack(&msg, writebuf, packlen);
        if (packlen > 0) {
            printf("< %s\n", res.DebugString().c_str());
            res.SerializeToArray(writebuf + PROTORPC_HEAD_LENGTH, msg.head.length);
            channel->write(writebuf, packlen);
        }
        HV_FREE(writebuf);
    }
};

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: %s port\n", argv[0]);
        return -10;
    }
    int port = atoi(argv[1]);

    ProtoRpcServer srv;
    int listenfd = srv.listen(port);
    if (listenfd < 0) {
        return -20;
    }
    printf("protorpc_server listen on port %d, listenfd=%d ...\n", port, listenfd);
    srv.setThreadNum(4);
    srv.start();

    while (1) hv_sleep(1);
    return 0;
}
```
æµç¨‹å¾ˆæ¸…æ™°ï¼Œå¯åŠ¨ä¸€ä¸ª`TcpServer`ï¼Œç›‘å¬æŒ‡å®šç«¯å£ï¼Œé€šè¿‡`setUnpack`æ¥å£è®¾ç½®æ‹†åŒ…è§„åˆ™ï¼Œ`onMessage`å›è°ƒä¸Šæ¥å°±æ˜¯å®Œæ•´çš„ä¸€åŒ…æ•°æ®ï¼Œå›è°ƒé‡Œè°ƒç”¨`protorpc_unpack`æ‹†åŒ…ã€`Request::ParseFromArray`ååºåˆ—åŒ–å¾—åˆ°ç»“æ„åŒ–çš„è¯·æ±‚ï¼Œé€šè¿‡è¯·æ±‚é‡Œçš„`method`å­—æ®µæŸ¥æ‰¾æ³¨å†Œå¥½çš„`routerè·¯ç”±è¡¨`ï¼Œè°ƒç”¨å¯¹åº”çš„`handler`å¤„ç†è¯·æ±‚ã€å¡«å……å“åº”ï¼Œç„¶å`Response::SerializeToArray` åºåˆ—åŒ–å“åº”+`protorpc_pack` åŠ ä¸Šå¤´éƒ¨å°åŒ…åï¼Œæœ€åè°ƒç”¨`Channel::write`å‘é€å‡ºå»ã€‚

[base.proto](../examples/protorpc/proto)å®šä¹‰å¦‚ä¸‹:
```c
syntax = "proto3";

package protorpc;

message Error {
    int32   code    = 1;
    string  message = 2;
}

message Request {
    uint64  id      = 1;
    string  method  = 2;
    repeated bytes params  = 3;
}

message Response {
    uint64  id      = 1;
    optional bytes  result  = 2;
    optional Error  error   = 3;
}
```
æ‰§è¡Œè¯¥ç›®å½•ä¸‹çš„`protoc.sh`ä¼šè°ƒç”¨`protoc`æ ¹æ®`proto`å®šä¹‰æ–‡ä»¶è‡ªåŠ¨ç”Ÿæˆå¯¹åº”ä»£ç ã€‚

## æµ‹è¯•æ­¥éª¤
```bash
git clone https://github.com/ithewei/libhv
cd libhv
make protorpc
bin/protorpc_server 1234
bin/protorpc_client 127.0.0.1 1234 add 1 2
bin/protorpc_client 127.0.0.1 1234 div 1 0
bin/protorpc_client 127.0.0.1 1234 xyz 1 2
```

ç»“æœå¦‚ä¸‹ï¼š
æœåŠ¡ç«¯ï¼š
```bash
$ bin/protorpc_server 1234
protorpc_server listen on port 1234, listenfd=3 ...
```
å®¢æˆ·ç«¯ï¼š
```bash
$ bin/protorpc_client 127.0.0.1 1234 add 1 2
connected to 127.0.0.1:1234! connfd=4
id: 1
method: "login"
params: "\n\005admin\022\006123456"

login success!
user_id: 123456
token: "admin:123456"

id: 2
method: "add"
params: "\010\001"
params: "\010\002"

calc success!
1 add 2 = 3
disconnected to 127.0.0.1:1234! connfd=4
```

```bash
$ bin/protorpc_client 127.0.0.1 1234 div 1 0
connected to 127.0.0.1:1234! connfd=4
id: 1
method: "login"
params: "\n\005admin\022\006123456"

login success!
user_id: 123456
token: "admin:123456"

id: 2
method: "div"
params: "\010\001"
params: ""

RPC error:
code: 400
message: "Bad Request"

calc failed!
disconnected to 127.0.0.1:1234! connfd=4
```

```bash
$ bin/protorpc_client 127.0.0.1 1234 xyz 1 2
connected to 127.0.0.1:1234! connfd=4
id: 1
method: "login"
params: "\n\005admin\022\006123456"

login success!
user_id: 123456
token: "admin:123456"

id: 2
method: "xyz"
params: "\010\001"
params: "\010\002"

RPC error:
code: 404
message: "Not Found"

calc failed!
disconnected to 127.0.0.1:1234! connfd=4
```

------

# libhvæ•™ç¨‹16--å¤šçº¿ç¨‹/å¤šè¿›ç¨‹æœåŠ¡ç«¯ç¼–ç¨‹

æœ¬ç¯‡ä»‹ç»æœåŠ¡ç«¯ç¼–ç¨‹çš„`å¤šçº¿ç¨‹/å¤šè¿›ç¨‹æ¨¡å¼`ä»¥åŠä½¿ç”¨`libhv`å¦‚ä½•å®ç°ã€‚

## `one thread per connection`ï¼šæ¯ä¸ªè¿æ¥ä¸€ä¸ªçº¿ç¨‹
æ—©æœŸçš„`apache`å°±æ˜¯é‡‡ç”¨è¿™ç§æ¨¡å¼ï¼Œç”¨äºå­¦ä¹ æœåŠ¡ç«¯ç¼–ç¨‹çš„[Tinyhttpd](https://github.com/EZLippi/Tinyhttpd)ä¹Ÿæ˜¯è¿™ç§æ¨¡å¼ã€‚

ä¼ªä»£ç å¦‚ä¸‹ï¼š
```c
void* worker_thread(void* userdata) {
	int fd = (intptr_t)userdata;
	while (1) {
	    readbytes = read(fd, buf, len);
	    if (readbytes <= 0) {
	        close(fd);
	        break;
	    }
	    ...
	    writebytes = write(fd, buf, len);
	    if (writebytes <= 0) {
	        close(fd);
	        break;
	    }
	}
}

void* accept_thread(void* userdata) {
	int listenfd = (intptr_t)userdata;
	while (1) {
		int connfd = accept(listenfd, &sockaddr, &socklen);
		// åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ä¸ºè¿™ä¸ªè¿æ¥æœåŠ¡
		pthread_create(worker_thread, (void *)(intptr_t)connfd);
	}
}
```

è¿™ç§æ¨¡å¼çš„ç¼ºç‚¹æ˜¾è€Œæ˜“è§ï¼Œå› ä¸ºè¯»å†™éƒ½æ˜¯é˜»å¡çš„ï¼Œæ‰€ä»¥ä¸€ä¸ªIOçº¿ç¨‹åªèƒ½å¤„ç†ä¸€ä¸ªfdï¼Œå¯¹äºå®¢æˆ·ç«¯å°šå¯æ¥å—ï¼Œå¯¹äºæœåŠ¡ç«¯æ¥è¯´ï¼Œæ¯acceptä¸€ä¸ªè¿æ¥ï¼Œå°±åˆ›å»ºä¸€ä¸ªIOçº¿ç¨‹å»è¯»å†™è¿™ä¸ªå¥—æ¥å­—ï¼Œå¹¶å‘è¾¾åˆ°å‡ åƒå°±éœ€è¦åˆ›å»ºå‡ åƒä¸ªçº¿ç¨‹ï¼Œçº¿ç¨‹ä¸Šä¸‹æ–‡çš„åˆ‡æ¢å¼€é”€éƒ½ä¼šæŠŠç³»ç»Ÿå æ»¡ã€‚

## `one loop per thread`ï¼šæ¯ä¸ªçº¿ç¨‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯

å› ä¸º`BIO`ï¼ˆé˜»å¡IOï¼‰çš„å±€é™æ€§ï¼Œæ‰€ä»¥IOå¤šè·¯å¤ç”¨æœºåˆ¶åº”è¿è€Œç”Ÿï¼Œå¦‚æœ€æ—©æœŸçš„`select`ã€åæ¥çš„`poll`ï¼Œ`linuxçš„epoll`ã€`windowsçš„iocp`ã€`bsdçš„kqueue`ã€`solarisçš„port`ç­‰ï¼Œéƒ½å±äºIOå¤šè·¯å¤ç”¨æœºåˆ¶ã€‚`éé˜»å¡NIOæ­é…IOå¤šè·¯å¤ç”¨æœºåˆ¶å°±æ˜¯é«˜å¹¶å‘çš„é’¥åŒ™`ã€‚

æ¯ä¸ªçº¿ç¨‹é‡Œè¿è¡Œä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œæ¯ä¸ªäº‹ä»¶å¾ªç¯é‡Œé€šè¿‡IOå¤šè·¯å¤ç”¨æœºåˆ¶ï¼ˆå³`selectã€pollã€epollã€kqueue`ç­‰ï¼‰ç›‘å¬è¯»å†™äº‹ä»¶ï¼Œè¿™æ­£æ˜¯`libeventã€libevã€libuvã€libhv`è¿™ç±»äº‹ä»¶å¾ªç¯åº“çš„æ ¸å¿ƒæ€æƒ³ã€‚

ä»¥`select`ä¸ºä¾‹ï¼Œä¼ªä»£ç å¦‚ä¸‹ï¼š
```c
void event_loop_run() {
	while (1) {
	    int nselect = select(max_fd+1, &readfds, &writefds, &exceptfds, timeout);
	    if (nselect == 0) continue;
	    for (int fd = 0; fd <= max_fd; ++fd) {
	    	// å¯è¯»
	    	if (FD_ISSET(fd, &readfds)) {
	    		...
	    		read(fd, buf, len);
	    	}
	    	// å¯å†™
	    	if (FD_ISSET(fd, &writefds)) {
	    		...
	    		write(fd, buf, len);
	    	}
	    }
	}
}
```

é€šè¿‡IOå¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œä¸€ä¸ªIOçº¿ç¨‹å°±å¯ä»¥åŒæ—¶ç›‘å¬å¤šä¸ªfdäº†ï¼Œä»¥ç°ä»£è®¡ç®—æœºçš„æ€§èƒ½ï¼Œä¸€ä¸ªIOçº¿ç¨‹å³å¯å¤„ç†å‡ åä¸‡æ•°é‡çº§åˆ«çš„IOè¯»å†™ã€‚`redis`å°±æ˜¯å•çº¿ç¨‹çš„ï¼Œä½†å¯è½»æ¾è¾¾åˆ°å‡ ä¸‡`QPS`ã€‚

ä¸ºäº†å……åˆ†åˆ©ç”¨ç°ä»£è®¡ç®—æœºçš„å¤šæ ¸å¤„ç†å™¨ï¼ŒæŒæ¡å¤šçº¿ç¨‹æœåŠ¡ç«¯ç¼–ç¨‹ä¹Ÿå°±å¿…ä¸å¯å°‘äº†ã€‚
`libhv`çš„ [examples/multi-thread](https://github.com/ithewei/libhv/tree/master/examples/multi-thread) ç›®å½•ä¸‹ç»™å‡ºäº†å‡ ç§å¸¸è§çš„å¤šçº¿ç¨‹/å¤šè¿›ç¨‹æ¨¡å¼çš„å…·ä½“å†™æ³•ã€‚

### `multi-acceptor-processes`ï¼šå¤šacceptè¿›ç¨‹æ¨¡å¼
```c
/*
 *
 * @build   make examples
 * @server  bin/multi-acceptor-processes 1234
 * @client  bin/nc 127.0.0.1 1234
 *          nc     127.0.0.1 1234
 *          telnet 127.0.0.1 1234
 */

#include "hloop.h"
#include "hsocket.h"
#include "hthread.h"
#include "hproc.h"

static const char* host = "0.0.0.0";
static int port = 1234;
static int process_num = 4;
static int listenfd = INVALID_SOCKET;

static void on_close(hio_t* io) {
    printf("on_close fd=%d error=%d\n", hio_fd(io), hio_error(io));
}

static void on_recv(hio_t* io, void* buf, int readbytes) {
    // echo
    hio_write(io, buf, readbytes);
}

static void on_accept(hio_t* io) {
    char localaddrstr[SOCKADDR_STRLEN] = {0};
    char peeraddrstr[SOCKADDR_STRLEN] = {0};
    printf("pid=%ld connfd=%d [%s] <= [%s]\n",
            (long)hv_getpid(),
            (int)hio_fd(io),
            SOCKADDR_STR(hio_localaddr(io), localaddrstr),
            SOCKADDR_STR(hio_peeraddr(io), peeraddrstr));

    hio_setcb_close(io, on_close);
    hio_setcb_read(io, on_recv);
    hio_read(io);
}

static void loop_proc(void* userdata) {
    hloop_t* loop = hloop_new(HLOOP_FLAG_AUTO_FREE);
    haccept(loop, listenfd, on_accept);
    hloop_run(loop);
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: cmd port\n");
        return -10;
    }
    port = atoi(argv[1]);

    listenfd = Listen(port, host);
    if (listenfd < 0) {
        exit(1);
    }

    proc_ctx_t ctx;
    memset(&ctx, 0, sizeof(ctx));
    ctx.proc = loop_proc;
    for (int i = 0; i < process_num; ++i) {
        hproc_spawn(&ctx);
    }

    while(1) hv_sleep(1);

    return 0;
}
```
å…³é”®ä¹‹å¤„å°±æ˜¯é€šè¿‡`hproc_spawn`ï¼ˆlinuxä¸‹å°±æ˜¯è°ƒç”¨`fork`ï¼‰è¡ç”Ÿå­è¿›ç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹é‡Œè¿è¡Œä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼ˆ`hloop_run`ï¼‰ï¼Œ`accept`è¯·æ±‚ï¼Œå°†è¿æ¥ä¸Šæ¥çš„fdåŠ å…¥åˆ°IOå¤šè·¯å¤ç”¨ä¸­ï¼Œç›‘å¬è¯»å†™äº‹ä»¶ã€‚

å¤šè¿›ç¨‹æ¨¡å¼çš„å¥½å¤„å°±æ˜¯çˆ¶è¿›ç¨‹å¯é€šè¿‡æ•è·`SIGCHLD`ä¿¡å·ï¼Œå³å¯çŸ¥é“å­è¿›ç¨‹é€€å‡ºäº†ï¼ˆé€šå¸¸æ˜¯å¼‚å¸¸å´©æºƒäº†ï¼‰ï¼Œç„¶åé‡æ–°`fork`ä¸€ä¸ªå­è¿›ç¨‹ï¼Œå³å´©æºƒè‡ªåŠ¨é‡å¯åŠŸèƒ½ã€‚è€Œä¸”å› ä¸ºè¿›ç¨‹ç©ºé—´çš„éš”ç¦»ï¼Œä¸€ä¸ªå­è¿›ç¨‹çš„å´©æºƒä¸ä¼šå½±å“å…¶å®ƒçš„å­è¿›ç¨‹ï¼Œå¯¼è‡´æ‰€æœ‰æœåŠ¡è¿›ç¨‹éƒ½ä¸å¯ç”¨ï¼Œæ‰€ä»¥é²æ£’æ€§æ¯”è¾ƒå¼ºï¼Œ`nginx`å°±æ˜¯é‡‡ç”¨çš„`å¤šè¿›ç¨‹æ¨¡å¼`ã€‚libhvä¸­æä¾›çš„httpdç¤ºä¾‹ä¹Ÿæ˜¯å¦‚æ­¤ã€‚![httpd](https://img-blog.csdnimg.cn/14a41c423f6f418182885dd133913213.png)
æ³¨ï¼šlibhvä¸­æä¾›äº†ä¸€ä¸ªæ¥å£`master_workers_run`æ¥å®ç°è¿™ç§å¸¦å´©æºƒè‡ªåŠ¨é‡å¯çš„`master-workers`å¤šè¿›ç¨‹æ¨¡å¼ï¼Œå…·ä½“ç¤ºä¾‹å¯å‚è€ƒ [examples/hmain_test.cpp](../examples/hmain_test.cpp)

### `multi-acceptor-threads`ï¼šå¤šacceptçº¿ç¨‹æ¨¡å¼
```c
/*
 *
 * @build   make examples
 * @server  bin/multi-acceptor-threads 1234
 * @client  bin/nc 127.0.0.1 1234
 *          nc     127.0.0.1 1234
 *          telnet 127.0.0.1 1234
 */

#include "hloop.h"
#include "hsocket.h"
#include "hthread.h"

static const char* host = "0.0.0.0";
static int port = 1234;
static int thread_num = 4;
static int listenfd = INVALID_SOCKET;

static void on_close(hio_t* io) {
    printf("on_close fd=%d error=%d\n", hio_fd(io), hio_error(io));
}

static void on_recv(hio_t* io, void* buf, int readbytes) {
    // echo
    hio_write(io, buf, readbytes);
}

static void on_accept(hio_t* io) {
    char localaddrstr[SOCKADDR_STRLEN] = {0};
    char peeraddrstr[SOCKADDR_STRLEN] = {0};
    printf("tid=%ld connfd=%d [%s] <= [%s]\n",
            (long)hv_gettid(),
            (int)hio_fd(io),
            SOCKADDR_STR(hio_localaddr(io), localaddrstr),
            SOCKADDR_STR(hio_peeraddr(io), peeraddrstr));

    hio_setcb_close(io, on_close);
    hio_setcb_read(io, on_recv);
    hio_read(io);
}

static HTHREAD_RETTYPE loop_thread(void* userdata) {
    hloop_t* loop = hloop_new(HLOOP_FLAG_AUTO_FREE);
    haccept(loop, listenfd, on_accept);
    hloop_run(loop);
    return 0;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: cmd port\n");
        return -10;
    }
    port = atoi(argv[1]);

    listenfd = Listen(port, host);
    if (listenfd < 0) {
        exit(1);
    }

    for (int i = 0; i < thread_num; ++i) {
        hthread_create(loop_thread, NULL);
    }

    while(1) hv_sleep(1);

    return 0;
}
```
å’Œä¸Šé¢å¤šè¿›ç¨‹ç±»ä¼¼ï¼Œåªä¸è¿‡æ˜¯è°ƒç”¨äº†`hthread_create`ï¼ˆlinuxä¸‹å°±æ˜¯`pthread_create`ï¼‰åˆ›å»ºçº¿ç¨‹è€Œä¸æ˜¯è¿›ç¨‹ï¼Œç„¶åæ¯ä¸ªçº¿ç¨‹é‡Œè¿è¡Œä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼ˆ`hloop_run`ï¼‰ã€‚

å¤šçº¿ç¨‹æ¨¡å¼ç›¸å¯¹äºå¤šè¿›ç¨‹æ¨¡å¼çš„å¥½å¤„å°±æ˜¯å…±äº«è¿›ç¨‹ç©ºé—´ï¼Œå³å…±äº«æ•°æ®ï¼Œè€Œä¸æ˜¯æ¯ä¸ªè¿›ç¨‹ä¸€ä»½èµ„æºï¼Œå½“ç„¶è¿™ä¹Ÿå¸¦æ¥äº†å¤šçº¿ç¨‹åŒæ­¥çš„éº»çƒ¦ã€‚

### `one-acceptor-multi-workers`ï¼šä¸€ä¸ªacceptçº¿ç¨‹+å¤šworkerçº¿ç¨‹
```c
/*
 *
 * @build   make examples
 * @server  bin/one-acceptor-multi-workers 1234
 * @client  bin/nc 127.0.0.1 1234
 *          nc     127.0.0.1 1234
 *          telnet 127.0.0.1 1234
 */

#include "hloop.h"
#include "hsocket.h"
#include "hthread.h"

static const char* host = "0.0.0.0";
static int port = 1234;
static int thread_num = 4;
static hloop_t*  accept_loop = NULL;
static hloop_t** worker_loops = NULL;

static hloop_t* get_next_loop() {
    static int s_cur_index = 0;
    if (s_cur_index == thread_num) {
        s_cur_index = 0;
    }
    return worker_loops[s_cur_index++];
}

static void on_close(hio_t* io) {
    printf("on_close fd=%d error=%d\n", hio_fd(io), hio_error(io));
}

static void on_recv(hio_t* io, void* buf, int readbytes) {
    // echo
    hio_write(io, buf, readbytes);
}

static void new_conn_event(hevent_t* ev) {
    hloop_t* loop = ev->loop;
    hio_t* io = (hio_t*)hevent_userdata(ev);
    hio_attach(loop, io);

    char localaddrstr[SOCKADDR_STRLEN] = {0};
    char peeraddrstr[SOCKADDR_STRLEN] = {0};
    printf("tid=%ld connfd=%d [%s] <= [%s]\n",
            (long)hv_gettid(),
            (int)hio_fd(io),
            SOCKADDR_STR(hio_localaddr(io), localaddrstr),
            SOCKADDR_STR(hio_peeraddr(io), peeraddrstr));

    hio_setcb_close(io, on_close);
    hio_setcb_read(io, on_recv);
    hio_read(io);
}

static void on_accept(hio_t* io) {
    hio_detach(io);

    hloop_t* worker_loop = get_next_loop();
    hevent_t ev;
    memset(&ev, 0, sizeof(ev));
    ev.loop = worker_loop;
    ev.cb = new_conn_event;
    ev.userdata = io;
    hloop_post_event(worker_loop, &ev);
}

static HTHREAD_RETTYPE worker_thread(void* userdata) {
    hloop_t* loop = (hloop_t*)userdata;
    hloop_run(loop);
    return 0;
}

static HTHREAD_RETTYPE accept_thread(void* userdata) {
    hloop_t* loop = (hloop_t*)userdata;
    hio_t* listenio = hloop_create_tcp_server(loop, host, port, on_accept);
    if (listenio == NULL) {
        exit(1);
    }
    hloop_run(loop);
    return 0;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: cmd port\n");
        return -10;
    }
    port = atoi(argv[1]);

    worker_loops = (hloop_t**)malloc(sizeof(hloop_t*) * thread_num);
    for (int i = 0; i < thread_num; ++i) {
        worker_loops[i] = hloop_new(HLOOP_FLAG_AUTO_FREE);
        hthread_create(worker_thread, worker_loops[i]);
    }

    accept_loop = hloop_new(HLOOP_FLAG_AUTO_FREE);
    accept_thread(accept_loop);

    return 0;
}
```
è¿™ç§æ¨¡å¼ç›¸å¯¹äºä¸Šé¢`accept(listenfd, ...)`å’Œ`read/write(connfd, ...)`éƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹é‡Œï¼Œå¤šäº†ä¸€ä¸ªæ­¥éª¤ï¼Œå½“acceptçº¿ç¨‹æ¥æ”¶åˆ°ä¸€ä¸ªè¿æ¥æ—¶ï¼Œéœ€è¦æŒ‘é€‰ä¸€ä¸ªworker_loopï¼ˆç¤ºä¾‹é‡Œå°±æ˜¯ç®€å•çš„`è½®è¯¢`ç­–ç•¥ï¼Œå®é™…åº”ç”¨é‡Œå¯èƒ½è¿˜æœ‰æ ¹æ®`æœ€å°‘è¿æ¥æ•°`ã€`IP hash`ã€`URL hash`ç­‰`è´Ÿè½½å‡è¡¡ç­–ç•¥`)ï¼Œç„¶åé€šçŸ¥è¯¥worker_loopæœ‰æ–°çš„è¿æ¥åˆ°æ¥ï¼Œlibhvé‡Œæ˜¯é€šè¿‡`hloop_post_event`è¿™ä¸ªæ¥å£æ¥è¿›è¡Œ`äº‹ä»¶å¾ªç¯é—´é€šä¿¡`çš„ï¼Œè¿™ä¸ªæ¥å£æ˜¯`å¤šçº¿ç¨‹å®‰å…¨`çš„ï¼Œå†…éƒ¨å®ç°æ˜¯é¢„å…ˆåˆ›å»ºä¸€å¯¹`socketpair`ï¼Œå‘ä¸€ä¸ªfdå†™å…¥ï¼Œç›‘å¬å¦å¤–ä¸€ä¸ªfdå¯è¯»ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥è¯»ä¸‹ [event/hloop.c](../event/hloop.c) æºç ã€‚

è¿™ç§è¿æ¥åˆ†å‘æ¨¡å¼å…¶å®æ˜¯å½“ä¸‹æ¯”è¾ƒæµè¡Œçš„æ¨¡å¼ï¼Œå› ä¸ºæ¯”è¾ƒæ–¹ä¾¿æ§åˆ¶è´Ÿè½½å‡è¡¡ï¼Œä¸ä¼šå‡ºç°ä¸€éƒ¨åˆ†çº¿ç¨‹é¥±å’Œï¼Œä¸€éƒ¨åˆ†çº¿ç¨‹é¥¥é¥¿çš„ç°è±¡ï¼Œ`memcached`å³æ˜¯ä½¿ç”¨`libevent`å®ç°çš„è¿™ç§æ¨¡å¼ï¼Œä½†æ˜¯å› ä¸º`libevent`å¹¶æ²¡æœ‰æä¾›`hloop_post_event`ç±»ä¼¼æ¥å£ï¼Œæ‰€ä»¥éœ€è¦ç”¨æˆ·è‡ªå·±å®ç°ï¼Œè€Œä¸”`libevent`ä¹Ÿæ²¡æœ‰é›†æˆ`openssl`ã€ä¹Ÿæ²¡æœ‰æä¾›`æ‹†åŒ…ç»„åŒ…`ç­‰ç›¸å…³åŠŸèƒ½ï¼Œæ‰€ä»¥`memcached`é‡Œç½‘ç»œç¼–ç¨‹çš„ä»£ç å¹¶ä¸æ¸…æ™°å¥½è¯»ï¼Œå¦‚æœä½¿ç”¨libhvï¼Œæˆ‘æƒ³äº‹æƒ…ä¼šå˜å¾—è¶…çº§ç®€å•ã€‚

## last

ä»¥ä¸Šåªæ˜¯å±•ç¤ºäº†ç½‘ç»œIOç›¸å…³çš„å¤šçº¿ç¨‹æ¨¡å¼ï¼Œå®é™…æºåˆä¸šåŠ¡æ‰€æ¶‰åŠçš„å¤šçº¿ç¨‹ç¼–ç¨‹æ¯”è¿™ä¸ªæ›´åŠ å¤æ‚ï¼Œ`IOçº¿ç¨‹é‡Œæ˜¯ä¸å…è®¸åšå¤ªå¤šè€—æ—¶æ“ä½œçš„ï¼ˆä¸€èˆ¬åªåšæ¥æ”¶/å‘é€ã€è½»é‡çº§çš„æ‹†åŒ…/ç»„åŒ…ã€åºåˆ—åŒ–/ååºåˆ—åŒ–æ“ä½œï¼‰`ï¼Œå¦åˆ™ä¼šå½±å“çº¿ç¨‹é‡Œå…¶ä»–è¿æ¥çš„è¯»å†™ï¼Œæ‰€ä»¥å¦‚æœæ¶‰åŠCPUå¯†é›†å‹è®¡ç®—ï¼Œå¦‚éŸ³è§†é¢‘ç¼–è§£ç ã€äººè„¸è¯†åˆ«ã€è¿åŠ¨è¿½è¸ªç­‰ç®—æ³•æ£€æµ‹ï¼Œåˆ™éœ€è¦é…åˆ`é˜Ÿåˆ—`ï¼ˆæ ¹æ®ä¸šåŠ¡å¯èƒ½å«`æ¶ˆæ¯é˜Ÿåˆ—ã€è¯·æ±‚é˜Ÿåˆ—ã€ä»»åŠ¡é˜Ÿåˆ—ã€å¸§ç¼“å­˜`ç­‰ï¼‰+ `æ¶ˆè´¹è€…çº¿ç¨‹/çº¿ç¨‹æ± ` ï¼ˆå¦‚`è¯·æ±‚å¤„ç†çº¿ç¨‹ã€ä»»åŠ¡æ‰§è¡Œçº¿ç¨‹ã€ç¼–è§£ç çº¿ç¨‹`ç­‰ï¼‰ä½¿ç”¨ã€‚å¥½åœ¨`libhv`é‡Œ`hio_write`ã€`hio_close`éƒ½æ˜¯å¤šçº¿ç¨‹å®‰å…¨çš„ï¼Œè¿™å¯ä»¥è®©`ç½‘ç»œIOäº‹ä»¶å¾ªç¯çº¿ç¨‹é‡Œæ¥æ”¶æ•°æ®ã€æ‹†åŒ…ç»„åŒ…ã€ååºåˆ—åŒ–`åæ”¾å…¥é˜Ÿåˆ—ï¼Œ`æ¶ˆè´¹è€…çº¿ç¨‹ä»é˜Ÿåˆ—é‡Œå–å‡ºæ•°æ®ã€å¤„ç†åå‘é€å“åº”å’Œå…³é—­è¿æ¥`ï¼Œå˜å¾—æ›´åŠ ç®€å•ã€‚

# æ›´å¤šåç»­æ•™ç¨‹æ•¬è¯·æœŸå¾…